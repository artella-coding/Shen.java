"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun read-file-as-bytelist (V1347) (let Stream (open V1347 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V1348 V1349 V1350) (cond ((= -1 V1349) V1350) (true (shen.read-file-as-bytelist-help V1348 (read-byte V1348) (cons V1349 V1350)))))

(defun read-file-as-string (V1351) (let Stream (open V1351 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V1352 V1353 V1354) (cond ((= -1 V1353) (do (close V1352) V1354)) (true (shen.rfas-h V1352 (read-byte V1352) (cn V1354 (n->string V1353))))))

(defun input (V1355) (eval-kl (read V1355)))

(defun input+ (V1356 V1357) (let Mono? (shen.monotype V1356) (let Input (read V1357) (if (= false (shen.typecheck Input V1356)) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V1356 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V1358) (cond ((cons? V1358) (map (lambda X1337 (shen.monotype X1337)) V1358)) (true (if (variable? V1358) (simple-error (cn "input+ expects a monotype: not " (shen.app V1358 "
" shen.a))) V1358))))

(defun read (V1359) (hd (shen.read-loop V1359 (read-byte V1359) ())))

(defun shen.read-loop (V1362 V1363 V1364) (cond ((= -1 V1363) (if (empty? V1364) (simple-error "error: empty stream") (compile (lambda X1338 (shen.<st_input> X1338)) V1364 (lambda E E)))) ((shen.terminator? V1363) (let AllBytes (append V1364 (cons V1363 ())) (let Read (compile (lambda X1339 (shen.<st_input> X1339)) AllBytes (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V1362 (read-byte V1362) AllBytes) Read)))) (true (shen.read-loop V1362 (read-byte V1362) (append V1364 (cons V1363 ()))))))

(defun shen.terminator? (V1365) (element? V1365 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V1366) (shen.lineread-loop (read-byte V1366) () V1366))

(defun shen.lineread-loop (V1368 V1369 V1370) (cond ((= -1 V1368) (if (empty? V1369) (simple-error "empty stream") (compile (lambda X1340 (shen.<st_input> X1340)) V1369 (lambda E E)))) ((= V1368 (shen.hat)) (simple-error "line read aborted")) ((element? V1368 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X1341 (shen.<st_input> X1341)) V1369 (lambda E shen.nextline)) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-byte V1370) (append V1369 (cons V1368 ())) V1370) Line))) (true (shen.lineread-loop (read-byte V1370) (append V1369 (cons V1368 ())) V1370))))

(defun read-file (V1371) (let Bytelist (read-file-as-bytelist V1371) (compile (lambda X1342 (shen.<st_input> X1342)) Bytelist (lambda X1343 (shen.read-error X1343)))))

(defun read-from-string (V1372) (let Ns (map (lambda X1344 (string->n X1344)) (explode V1372)) (compile (lambda X1345 (shen.<st_input> X1345)) Ns (lambda X1346 (shen.read-error X1346)))))

(defun shen.read-error (V1379) (cond ((and (cons? V1379) (and (cons? (hd V1379)) (and (cons? (tl V1379)) (= () (tl (tl V1379)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V1379)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V1384 V1385) (cond ((= () V1385) "") ((= 0 V1384) "") ((cons? V1385) (cn (n->string (hd V1385)) (shen.compress-50 (- V1384 1) (tl V1385)))) (true (shen.sys-error shen.compress-50))))

(defun shen.<st_input> (V1390) (let Result (let Parse_shen.<lsb> (shen.<lsb> V1390) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<lrb> (shen.<lrb> V1390) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<lcurly> (shen.<lcurly> V1390) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<rcurly> (shen.<rcurly> V1390) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<bar> (shen.<bar> V1390) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<semicolon> (shen.<semicolon> V1390) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<colon> (shen.<colon> V1390) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<colon> (shen.<colon> V1390) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<colon> (shen.<colon> V1390) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<comma> (shen.<comma> V1390) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<comment> (shen.<comment> V1390) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<atom> (shen.<atom> V1390) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<whitespaces> (shen.<whitespaces> V1390) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1390) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.<lsb> (V1395) (let Result (if (and (cons? (hd V1395)) (= 91 (hd (hd V1395)))) (shen.pair (hd (shen.pair (tl (hd V1395)) (shen.hdtl V1395))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<rsb> (V1400) (let Result (if (and (cons? (hd V1400)) (= 93 (hd (hd V1400)))) (shen.pair (hd (shen.pair (tl (hd V1400)) (shen.hdtl V1400))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<lcurly> (V1405) (let Result (if (and (cons? (hd V1405)) (= 123 (hd (hd V1405)))) (shen.pair (hd (shen.pair (tl (hd V1405)) (shen.hdtl V1405))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<rcurly> (V1410) (let Result (if (and (cons? (hd V1410)) (= 125 (hd (hd V1410)))) (shen.pair (hd (shen.pair (tl (hd V1410)) (shen.hdtl V1410))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<bar> (V1415) (let Result (if (and (cons? (hd V1415)) (= 124 (hd (hd V1415)))) (shen.pair (hd (shen.pair (tl (hd V1415)) (shen.hdtl V1415))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<semicolon> (V1420) (let Result (if (and (cons? (hd V1420)) (= 59 (hd (hd V1420)))) (shen.pair (hd (shen.pair (tl (hd V1420)) (shen.hdtl V1420))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<colon> (V1425) (let Result (if (and (cons? (hd V1425)) (= 58 (hd (hd V1425)))) (shen.pair (hd (shen.pair (tl (hd V1425)) (shen.hdtl V1425))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<comma> (V1430) (let Result (if (and (cons? (hd V1430)) (= 44 (hd (hd V1430)))) (shen.pair (hd (shen.pair (tl (hd V1430)) (shen.hdtl V1430))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<equal> (V1435) (let Result (if (and (cons? (hd V1435)) (= 61 (hd (hd V1435)))) (shen.pair (hd (shen.pair (tl (hd V1435)) (shen.hdtl V1435))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<minus> (V1440) (let Result (if (and (cons? (hd V1440)) (= 45 (hd (hd V1440)))) (shen.pair (hd (shen.pair (tl (hd V1440)) (shen.hdtl V1440))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<lrb> (V1445) (let Result (if (and (cons? (hd V1445)) (= 40 (hd (hd V1445)))) (shen.pair (hd (shen.pair (tl (hd V1445)) (shen.hdtl V1445))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<rrb> (V1450) (let Result (if (and (cons? (hd V1450)) (= 41 (hd (hd V1450)))) (shen.pair (hd (shen.pair (tl (hd V1450)) (shen.hdtl V1450))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<atom> (V1455) (let Result (let Parse_shen.<str> (shen.<str> V1455) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<number> (shen.<number> V1455) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<sym> (shen.<sym> V1455) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)))

(defun shen.control-chars (V1456) (cond ((= () V1456) "") ((and (cons? V1456) (and (= "c" (hd V1456)) (and (cons? (tl V1456)) (= "#" (hd (tl V1456)))))) (let CodePoint (shen.code-point (tl (tl V1456))) (let AfterCodePoint (shen.after-codepoint (tl (tl V1456))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V1456) (@s (hd V1456) (shen.control-chars (tl V1456)))) (true (shen.sys-error shen.control-chars))))

(defun shen.code-point (V1459) (cond ((and (cons? V1459) (= ";" (hd V1459))) "") ((and (cons? V1459) (element? (hd V1459) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V1459) (shen.code-point (tl V1459)))) (true (simple-error (cn "code point parse error " (shen.app V1459 "
" shen.a))))))

(defun shen.after-codepoint (V1464) (cond ((= () V1464) ()) ((and (cons? V1464) (= ";" (hd V1464))) (tl V1464)) ((cons? V1464) (shen.after-codepoint (tl V1464))) (true (shen.sys-error shen.after-codepoint))))

(defun shen.decimalise (V1465) (shen.pre (reverse (shen.digits->integers V1465)) 0))

(defun shen.digits->integers (V1470) (cond ((and (cons? V1470) (= "0" (hd V1470))) (cons 0 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "1" (hd V1470))) (cons 1 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "2" (hd V1470))) (cons 2 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "3" (hd V1470))) (cons 3 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "4" (hd V1470))) (cons 4 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "5" (hd V1470))) (cons 5 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "6" (hd V1470))) (cons 6 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "7" (hd V1470))) (cons 7 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "8" (hd V1470))) (cons 8 (shen.digits->integers (tl V1470)))) ((and (cons? V1470) (= "9" (hd V1470))) (cons 9 (shen.digits->integers (tl V1470)))) (true ())))

(defun shen.<sym> (V1475) (let Result (let Parse_shen.<alpha> (shen.<alpha> V1475) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<alphanums> (V1480) (let Result (let Parse_shen.<alphanum> (shen.<alphanum> V1480) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1480) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<alphanum> (V1485) (let Result (let Parse_shen.<alpha> (shen.<alpha> V1485) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<num> (shen.<num> V1485) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<num> (V1490) (let Result (if (cons? (hd V1490)) (let Parse_Byte (hd (hd V1490)) (if (shen.numbyte? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V1490)) (shen.hdtl V1490))) (n->string Parse_Byte)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.numbyte? (V1495) (cond ((= 48 V1495) true) ((= 49 V1495) true) ((= 50 V1495) true) ((= 51 V1495) true) ((= 52 V1495) true) ((= 53 V1495) true) ((= 54 V1495) true) ((= 55 V1495) true) ((= 56 V1495) true) ((= 57 V1495) true) (true false)))

(defun shen.<alpha> (V1500) (let Result (if (cons? (hd V1500)) (let Parse_Byte (hd (hd V1500)) (if (shen.symbol-code? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V1500)) (shen.hdtl V1500))) (n->string Parse_Byte)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.symbol-code? (V1501) (or (= V1501 126) (or (and (> V1501 94) (< V1501 123)) (or (and (> V1501 59) (< V1501 91)) (or (and (> V1501 41) (and (< V1501 58) (not (= V1501 44)))) (or (and (> V1501 34) (< V1501 40)) (= V1501 33)))))))

(defun shen.<str> (V1506) (let Result (let Parse_shen.<dbq> (shen.<dbq> V1506) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<dbq> (V1511) (let Result (if (cons? (hd V1511)) (let Parse_Byte (hd (hd V1511)) (if (= Parse_Byte 34) (shen.pair (hd (shen.pair (tl (hd V1511)) (shen.hdtl V1511))) Parse_Byte) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<strcontents> (V1516) (let Result (let Parse_shen.<strc> (shen.<strc> V1516) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1516) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<byte> (V1521) (let Result (if (cons? (hd V1521)) (let Parse_Byte (hd (hd V1521)) (shen.pair (hd (shen.pair (tl (hd V1521)) (shen.hdtl V1521))) (n->string Parse_Byte))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<strc> (V1526) (let Result (if (cons? (hd V1526)) (let Parse_Byte (hd (hd V1526)) (if (not (= Parse_Byte 34)) (shen.pair (hd (shen.pair (tl (hd V1526)) (shen.hdtl V1526))) (n->string Parse_Byte)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<number> (V1531) (let Result (let Parse_shen.<minus> (shen.<minus> V1531) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<plus> (shen.<plus> V1531) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<predigits> (shen.<predigits> V1531) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<digits> (shen.<digits> V1531) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<predigits> (shen.<predigits> V1531) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<digits> (shen.<digits> V1531) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.<E> (V1536) (let Result (if (and (cons? (hd V1536)) (= 101 (hd (hd V1536)))) (shen.pair (hd (shen.pair (tl (hd V1536)) (shen.hdtl V1536))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<log10> (V1541) (let Result (let Parse_shen.<minus> (shen.<minus> V1541) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<digits> (shen.<digits> V1541) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<plus> (V1546) (let Result (if (cons? (hd V1546)) (let Parse_Byte (hd (hd V1546)) (if (= Parse_Byte 43) (shen.pair (hd (shen.pair (tl (hd V1546)) (shen.hdtl V1546))) Parse_Byte) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<stop> (V1551) (let Result (if (cons? (hd V1551)) (let Parse_Byte (hd (hd V1551)) (if (= Parse_Byte 46) (shen.pair (hd (shen.pair (tl (hd V1551)) (shen.hdtl V1551))) Parse_Byte) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<predigits> (V1556) (let Result (let Parse_shen.<digits> (shen.<digits> V1556) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1556) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<postdigits> (V1561) (let Result (let Parse_shen.<digits> (shen.<digits> V1561) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<digits> (V1566) (let Result (let Parse_shen.<digit> (shen.<digit> V1566) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<digit> (shen.<digit> V1566) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<digit> (V1571) (let Result (if (cons? (hd V1571)) (let Parse_X (hd (hd V1571)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1571)) (shen.hdtl V1571))) (shen.byte->digit Parse_X)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.byte->digit (V1572) (cond ((= 48 V1572) 0) ((= 49 V1572) 1) ((= 50 V1572) 2) ((= 51 V1572) 3) ((= 52 V1572) 4) ((= 53 V1572) 5) ((= 54 V1572) 6) ((= 55 V1572) 7) ((= 56 V1572) 8) ((= 57 V1572) 9) (true (shen.sys-error shen.byte->digit))))

(defun shen.pre (V1575 V1576) (cond ((= () V1575) 0) ((cons? V1575) (+ (* (shen.expt 10 V1576) (hd V1575)) (shen.pre (tl V1575) (+ V1576 1)))) (true (shen.sys-error shen.pre))))

(defun shen.post (V1579 V1580) (cond ((= () V1579) 0) ((cons? V1579) (+ (* (shen.expt 10 (- 0 V1580)) (hd V1579)) (shen.post (tl V1579) (+ V1580 1)))) (true (shen.sys-error shen.post))))

(defun shen.expt (V1583 V1584) (cond ((= 0 V1584) 1) ((> V1584 0) (* V1583 (shen.expt V1583 (- V1584 1)))) (true (* 1 (/ (shen.expt V1583 (+ V1584 1)) V1583)))))

(defun shen.<st_input1> (V1589) (let Result (let Parse_shen.<st_input> (shen.<st_input> V1589) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<st_input2> (V1594) (let Result (let Parse_shen.<st_input> (shen.<st_input> V1594) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<comment> (V1599) (let Result (let Parse_shen.<singleline> (shen.<singleline> V1599) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<multiline> (shen.<multiline> V1599) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<singleline> (V1604) (let Result (let Parse_shen.<backslash> (shen.<backslash> V1604) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<backslash> (V1609) (let Result (if (and (cons? (hd V1609)) (= 92 (hd (hd V1609)))) (shen.pair (hd (shen.pair (tl (hd V1609)) (shen.hdtl V1609))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<anysingle> (V1614) (let Result (let Parse_shen.<non-return> (shen.<non-return> V1614) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1614) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<non-return> (V1619) (let Result (if (cons? (hd V1619)) (let Parse_X (hd (hd V1619)) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (tl (hd V1619)) (shen.hdtl V1619))) shen.skip) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<return> (V1624) (let Result (if (cons? (hd V1624)) (let Parse_X (hd (hd V1624)) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (tl (hd V1624)) (shen.hdtl V1624))) shen.skip) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<multiline> (V1629) (let Result (let Parse_shen.<backslash> (shen.<backslash> V1629) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<times> (V1634) (let Result (if (and (cons? (hd V1634)) (= 42 (hd (hd V1634)))) (shen.pair (hd (shen.pair (tl (hd V1634)) (shen.hdtl V1634))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<anymulti> (V1639) (let Result (let Parse_shen.<comment> (shen.<comment> V1639) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<times> (shen.<times> V1639) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= Result (fail)) (let Result (if (cons? (hd V1639)) (let Parse_X (hd (hd V1639)) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (tl (hd V1639)) (shen.hdtl V1639))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) (if (= Result (fail)) (fail) Result)) Result)) Result)))

(defun shen.<whitespaces> (V1644) (let Result (let Parse_shen.<whitespace> (shen.<whitespace> V1644) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<whitespace> (shen.<whitespace> V1644) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<whitespace> (V1649) (let Result (if (cons? (hd V1649)) (let Parse_X (hd (hd V1649)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V1649)) (shen.hdtl V1649))) shen.skip) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.cons_form (V1650) (cond ((= () V1650) ()) ((and (cons? V1650) (and (cons? (tl V1650)) (and (cons? (tl (tl V1650))) (and (= () (tl (tl (tl V1650)))) (= (hd (tl V1650)) bar!))))) (cons cons (cons (hd V1650) (tl (tl V1650))))) ((cons? V1650) (cons cons (cons (hd V1650) (cons (shen.cons_form (tl V1650)) ())))) (true (shen.sys-error shen.cons_form))))

(defun shen.package-macro (V1653 V1654) (cond ((and (cons? V1653) (and (= $ (hd V1653)) (and (cons? (tl V1653)) (= () (tl (tl V1653)))))) (append (explode (hd (tl V1653))) V1654)) ((and (cons? V1653) (and (= package (hd V1653)) (and (cons? (tl V1653)) (and (= null (hd (tl V1653))) (cons? (tl (tl V1653))))))) (append (tl (tl (tl V1653))) V1654)) ((and (cons? V1653) (and (= package (hd V1653)) (and (cons? (tl V1653)) (cons? (tl (tl V1653)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V1653)))) (let Record (shen.record-exceptions ListofExceptions (hd (tl V1653))) (let PackageNameDot (intern (cn (str (hd (tl V1653))) ".")) (append (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V1653)))) V1654))))) (true (cons V1653 V1654))))

(defun shen.record-exceptions (V1655 V1656) (let CurrExceptions (trap-error (get V1656 shen.external-symbols (value *property-vector*)) (lambda E ())) (let AllExceptions (union V1655 CurrExceptions) (put V1656 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.packageh (V1665 V1666 V1667) (cond ((cons? V1667) (cons (shen.packageh V1665 V1666 (hd V1667)) (shen.packageh V1665 V1666 (tl V1667)))) ((or (shen.sysfunc? V1667) (or (variable? V1667) (or (element? V1667 V1666) (or (shen.doubleunderline? V1667) (shen.singleunderline? V1667))))) V1667) ((and (symbol? V1667) (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) (explode V1667)))) (concat V1665 V1667)) (true V1667)))



