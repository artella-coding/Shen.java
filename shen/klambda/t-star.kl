"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2821 V2822) (let Curry (shen.curry V2821) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2822)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2823) (cond ((and (cons? V2823) (shen.special? (hd V2823))) (cons (hd V2823) (map shen.curry (tl V2823)))) ((and (cons? V2823) (and (cons? (tl V2823)) (shen.extraspecial? (hd V2823)))) V2823) ((and (cons? V2823) (and (= type (hd V2823)) (and (cons? (tl V2823)) (and (cons? (tl (tl V2823))) (= () (tl (tl (tl V2823)))))))) (cons type (cons (shen.curry (hd (tl V2823))) (tl (tl V2823))))) ((and (cons? V2823) (and (cons? (tl V2823)) (cons? (tl (tl V2823))))) (shen.curry (cons (cons (hd V2823) (cons (hd (tl V2823)) ())) (tl (tl V2823))))) ((and (cons? V2823) (and (cons? (tl V2823)) (= () (tl (tl V2823))))) (cons (shen.curry (hd V2823)) (cons (shen.curry (hd (tl V2823))) ()))) (true V2823)))

(defun shen.special? (V2824) (element? V2824 (value shen.*special*)))

(defun shen.extraspecial? (V2825) (element? V2825 (value shen.*extraspecial*)))

(defun shen.t* (V2826 V2827 V2828 V2829) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2828) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2828 (freeze (bind Error (shen.errormaxinfs) V2828 V2829))))) (if (= Case false) (let Case (let V2815 (shen.lazyderef V2826 V2828) (if (= fail V2815) (do (shen.incinfs) (cut Throwcontrol V2828 (freeze (shen.prolog-failure V2828 V2829)))) false)) (if (= Case false) (let Case (let V2816 (shen.lazyderef V2826 V2828) (if (cons? V2816) (let X (hd V2816) (let V2817 (shen.lazyderef (tl V2816) V2828) (if (cons? V2817) (let V2818 (shen.lazyderef (hd V2817) V2828) (if (= : V2818) (let V2819 (shen.lazyderef (tl V2817) V2828) (if (cons? V2819) (let A (hd V2819) (let V2820 (shen.lazyderef (tl V2819) V2828) (if (= () V2820) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2828 (freeze (cut Throwcontrol V2828 (freeze (shen.th* X A V2827 V2828 V2829)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2828) (do (shen.incinfs) (shen.show V2826 V2827 V2828 (freeze (bind Datatypes (value shen.*datatypes*) V2828 (freeze (shen.udefs* V2826 V2827 Datatypes V2828 V2829))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2834) (cond ((= + V2834) (set shen.*shen-type-theory-enabled?* true)) ((= - V2834) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2843 V2844) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2845 V2846 V2847 V2848 V2849) (let Case (let V2811 (shen.lazyderef V2847 V2848) (if (cons? V2811) (let D (hd V2811) (do (shen.incinfs) (call (cons D (cons V2845 (cons V2846 ()))) V2848 V2849))) false)) (if (= Case false) (let V2812 (shen.lazyderef V2847 V2848) (if (cons? V2812) (let Ds (tl V2812) (do (shen.incinfs) (shen.udefs* V2845 V2846 Ds V2848 V2849))) false)) Case)))

(defun shen.th* (V2850 V2851 V2852 V2853 V2854) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2850 (cons : (cons V2851 ()))) V2852 V2853 (freeze (fwhen false V2853 V2854)))) (if (= Case false) (let Case (let F (shen.newpv V2853) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2850 V2853)) V2853 (freeze (bind F (shen.sigf (shen.lazyderef V2850 V2853)) V2853 (freeze (call (cons F (cons V2851 ())) V2853 V2854))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2850 V2851 V2853 V2854)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2850 V2851 V2852 V2853 V2854)) (if (= Case false) (let Case (let V2696 (shen.lazyderef V2850 V2853) (if (cons? V2696) (let F (hd V2696) (let V2697 (shen.lazyderef (tl V2696) V2853) (if (= () V2697) (do (shen.incinfs) (shen.th* F (cons --> (cons V2851 ())) V2852 V2853 V2854)) false))) false)) (if (= Case false) (let Case (let V2698 (shen.lazyderef V2850 V2853) (if (cons? V2698) (let F (hd V2698) (let V2699 (shen.lazyderef (tl V2698) V2853) (if (cons? V2699) (let X (hd V2699) (let V2700 (shen.lazyderef (tl V2699) V2853) (if (= () V2700) (let B (shen.newpv V2853) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2851 ()))) V2852 V2853 (freeze (shen.th* X B V2852 V2853 V2854))))) false))) false))) false)) (if (= Case false) (let Case (let V2701 (shen.lazyderef V2850 V2853) (if (cons? V2701) (let V2702 (shen.lazyderef (hd V2701) V2853) (if (= cons V2702) (let V2703 (shen.lazyderef (tl V2701) V2853) (if (cons? V2703) (let X (hd V2703) (let V2704 (shen.lazyderef (tl V2703) V2853) (if (cons? V2704) (let Y (hd V2704) (let V2705 (shen.lazyderef (tl V2704) V2853) (if (= () V2705) (let V2706 (shen.lazyderef V2851 V2853) (if (cons? V2706) (let V2707 (shen.lazyderef (hd V2706) V2853) (if (= list V2707) (let V2708 (shen.lazyderef (tl V2706) V2853) (if (cons? V2708) (let A (hd V2708) (let V2709 (shen.lazyderef (tl V2708) V2853) (if (= () V2709) (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons list (cons A ())) V2852 V2853 V2854)))) (if (shen.pvar? V2709) (do (shen.bindv V2709 () V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons list (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2709 V2853) Result))) false)))) (if (shen.pvar? V2708) (let A (shen.newpv V2853) (do (shen.bindv V2708 (cons A ()) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons list (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2708 V2853) Result)))) false))) (if (shen.pvar? V2707) (do (shen.bindv V2707 list V2853) (let Result (let V2710 (shen.lazyderef (tl V2706) V2853) (if (cons? V2710) (let A (hd V2710) (let V2711 (shen.lazyderef (tl V2710) V2853) (if (= () V2711) (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons list (cons A ())) V2852 V2853 V2854)))) (if (shen.pvar? V2711) (do (shen.bindv V2711 () V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons list (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2711 V2853) Result))) false)))) (if (shen.pvar? V2710) (let A (shen.newpv V2853) (do (shen.bindv V2710 (cons A ()) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons list (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2710 V2853) Result)))) false))) (do (shen.unbindv V2707 V2853) Result))) false))) (if (shen.pvar? V2706) (let A (shen.newpv V2853) (do (shen.bindv V2706 (cons list (cons A ())) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons list (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2706 V2853) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2712 (shen.lazyderef V2850 V2853) (if (cons? V2712) (let V2713 (shen.lazyderef (hd V2712) V2853) (if (= @p V2713) (let V2714 (shen.lazyderef (tl V2712) V2853) (if (cons? V2714) (let X (hd V2714) (let V2715 (shen.lazyderef (tl V2714) V2853) (if (cons? V2715) (let Y (hd V2715) (let V2716 (shen.lazyderef (tl V2715) V2853) (if (= () V2716) (let V2717 (shen.lazyderef V2851 V2853) (if (cons? V2717) (let A (hd V2717) (let V2718 (shen.lazyderef (tl V2717) V2853) (if (cons? V2718) (let V2719 (shen.lazyderef (hd V2718) V2853) (if (= * V2719) (let V2720 (shen.lazyderef (tl V2718) V2853) (if (cons? V2720) (let B (hd V2720) (let V2721 (shen.lazyderef (tl V2720) V2853) (if (= () V2721) (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y B V2852 V2853 V2854)))) (if (shen.pvar? V2721) (do (shen.bindv V2721 () V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y B V2852 V2853 V2854)))) (do (shen.unbindv V2721 V2853) Result))) false)))) (if (shen.pvar? V2720) (let B (shen.newpv V2853) (do (shen.bindv V2720 (cons B ()) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y B V2852 V2853 V2854)))) (do (shen.unbindv V2720 V2853) Result)))) false))) (if (shen.pvar? V2719) (do (shen.bindv V2719 * V2853) (let Result (let V2722 (shen.lazyderef (tl V2718) V2853) (if (cons? V2722) (let B (hd V2722) (let V2723 (shen.lazyderef (tl V2722) V2853) (if (= () V2723) (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y B V2852 V2853 V2854)))) (if (shen.pvar? V2723) (do (shen.bindv V2723 () V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y B V2852 V2853 V2854)))) (do (shen.unbindv V2723 V2853) Result))) false)))) (if (shen.pvar? V2722) (let B (shen.newpv V2853) (do (shen.bindv V2722 (cons B ()) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y B V2852 V2853 V2854)))) (do (shen.unbindv V2722 V2853) Result)))) false))) (do (shen.unbindv V2719 V2853) Result))) false))) (if (shen.pvar? V2718) (let B (shen.newpv V2853) (do (shen.bindv V2718 (cons * (cons B ())) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y B V2852 V2853 V2854)))) (do (shen.unbindv V2718 V2853) Result)))) false)))) (if (shen.pvar? V2717) (let A (shen.newpv V2853) (let B (shen.newpv V2853) (do (shen.bindv V2717 (cons A (cons * (cons B ()))) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y B V2852 V2853 V2854)))) (do (shen.unbindv V2717 V2853) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2724 (shen.lazyderef V2850 V2853) (if (cons? V2724) (let V2725 (shen.lazyderef (hd V2724) V2853) (if (= @v V2725) (let V2726 (shen.lazyderef (tl V2724) V2853) (if (cons? V2726) (let X (hd V2726) (let V2727 (shen.lazyderef (tl V2726) V2853) (if (cons? V2727) (let Y (hd V2727) (let V2728 (shen.lazyderef (tl V2727) V2853) (if (= () V2728) (let V2729 (shen.lazyderef V2851 V2853) (if (cons? V2729) (let V2730 (shen.lazyderef (hd V2729) V2853) (if (= vector V2730) (let V2731 (shen.lazyderef (tl V2729) V2853) (if (cons? V2731) (let A (hd V2731) (let V2732 (shen.lazyderef (tl V2731) V2853) (if (= () V2732) (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons vector (cons A ())) V2852 V2853 V2854)))) (if (shen.pvar? V2732) (do (shen.bindv V2732 () V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons vector (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2732 V2853) Result))) false)))) (if (shen.pvar? V2731) (let A (shen.newpv V2853) (do (shen.bindv V2731 (cons A ()) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons vector (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2731 V2853) Result)))) false))) (if (shen.pvar? V2730) (do (shen.bindv V2730 vector V2853) (let Result (let V2733 (shen.lazyderef (tl V2729) V2853) (if (cons? V2733) (let A (hd V2733) (let V2734 (shen.lazyderef (tl V2733) V2853) (if (= () V2734) (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons vector (cons A ())) V2852 V2853 V2854)))) (if (shen.pvar? V2734) (do (shen.bindv V2734 () V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons vector (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2734 V2853) Result))) false)))) (if (shen.pvar? V2733) (let A (shen.newpv V2853) (do (shen.bindv V2733 (cons A ()) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons vector (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2733 V2853) Result)))) false))) (do (shen.unbindv V2730 V2853) Result))) false))) (if (shen.pvar? V2729) (let A (shen.newpv V2853) (do (shen.bindv V2729 (cons vector (cons A ())) V2853) (let Result (do (shen.incinfs) (shen.th* X A V2852 V2853 (freeze (shen.th* Y (cons vector (cons A ())) V2852 V2853 V2854)))) (do (shen.unbindv V2729 V2853) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2735 (shen.lazyderef V2850 V2853) (if (cons? V2735) (let V2736 (shen.lazyderef (hd V2735) V2853) (if (= @s V2736) (let V2737 (shen.lazyderef (tl V2735) V2853) (if (cons? V2737) (let X (hd V2737) (let V2738 (shen.lazyderef (tl V2737) V2853) (if (cons? V2738) (let Y (hd V2738) (let V2739 (shen.lazyderef (tl V2738) V2853) (if (= () V2739) (let V2740 (shen.lazyderef V2851 V2853) (if (= string V2740) (do (shen.incinfs) (shen.th* X string V2852 V2853 (freeze (shen.th* Y string V2852 V2853 V2854)))) (if (shen.pvar? V2740) (do (shen.bindv V2740 string V2853) (let Result (do (shen.incinfs) (shen.th* X string V2852 V2853 (freeze (shen.th* Y string V2852 V2853 V2854)))) (do (shen.unbindv V2740 V2853) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2741 (shen.lazyderef V2850 V2853) (if (cons? V2741) (let V2742 (shen.lazyderef (hd V2741) V2853) (if (= lambda V2742) (let V2743 (shen.lazyderef (tl V2741) V2853) (if (cons? V2743) (let X (hd V2743) (let V2744 (shen.lazyderef (tl V2743) V2853) (if (cons? V2744) (let Y (hd V2744) (let V2745 (shen.lazyderef (tl V2744) V2853) (if (= () V2745) (let V2746 (shen.lazyderef V2851 V2853) (if (cons? V2746) (let A (hd V2746) (let V2747 (shen.lazyderef (tl V2746) V2853) (if (cons? V2747) (let V2748 (shen.lazyderef (hd V2747) V2853) (if (= --> V2748) (let V2749 (shen.lazyderef (tl V2747) V2853) (if (cons? V2749) (let B (hd V2749) (let V2750 (shen.lazyderef (tl V2749) V2853) (if (= () V2750) (let Z (shen.newpv V2853) (let X&& (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Y V2853)) V2853 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2852) V2853 V2854)))))))))) (if (shen.pvar? V2750) (do (shen.bindv V2750 () V2853) (let Result (let Z (shen.newpv V2853) (let X&& (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Y V2853)) V2853 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2852) V2853 V2854)))))))))) (do (shen.unbindv V2750 V2853) Result))) false)))) (if (shen.pvar? V2749) (let B (shen.newpv V2853) (do (shen.bindv V2749 (cons B ()) V2853) (let Result (let Z (shen.newpv V2853) (let X&& (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Y V2853)) V2853 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2852) V2853 V2854)))))))))) (do (shen.unbindv V2749 V2853) Result)))) false))) (if (shen.pvar? V2748) (do (shen.bindv V2748 --> V2853) (let Result (let V2751 (shen.lazyderef (tl V2747) V2853) (if (cons? V2751) (let B (hd V2751) (let V2752 (shen.lazyderef (tl V2751) V2853) (if (= () V2752) (let Z (shen.newpv V2853) (let X&& (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Y V2853)) V2853 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2852) V2853 V2854)))))))))) (if (shen.pvar? V2752) (do (shen.bindv V2752 () V2853) (let Result (let Z (shen.newpv V2853) (let X&& (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Y V2853)) V2853 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2852) V2853 V2854)))))))))) (do (shen.unbindv V2752 V2853) Result))) false)))) (if (shen.pvar? V2751) (let B (shen.newpv V2853) (do (shen.bindv V2751 (cons B ()) V2853) (let Result (let Z (shen.newpv V2853) (let X&& (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Y V2853)) V2853 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2852) V2853 V2854)))))))))) (do (shen.unbindv V2751 V2853) Result)))) false))) (do (shen.unbindv V2748 V2853) Result))) false))) (if (shen.pvar? V2747) (let B (shen.newpv V2853) (do (shen.bindv V2747 (cons --> (cons B ())) V2853) (let Result (let Z (shen.newpv V2853) (let X&& (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Y V2853)) V2853 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2852) V2853 V2854)))))))))) (do (shen.unbindv V2747 V2853) Result)))) false)))) (if (shen.pvar? V2746) (let A (shen.newpv V2853) (let B (shen.newpv V2853) (do (shen.bindv V2746 (cons A (cons --> (cons B ()))) V2853) (let Result (let Z (shen.newpv V2853) (let X&& (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Y V2853)) V2853 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2852) V2853 V2854)))))))))) (do (shen.unbindv V2746 V2853) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2753 (shen.lazyderef V2850 V2853) (if (cons? V2753) (let V2754 (shen.lazyderef (hd V2753) V2853) (if (= let V2754) (let V2755 (shen.lazyderef (tl V2753) V2853) (if (cons? V2755) (let X (hd V2755) (let V2756 (shen.lazyderef (tl V2755) V2853) (if (cons? V2756) (let Y (hd V2756) (let V2757 (shen.lazyderef (tl V2756) V2853) (if (cons? V2757) (let Z (hd V2757) (let V2758 (shen.lazyderef (tl V2757) V2853) (if (= () V2758) (let W (shen.newpv V2853) (let X&& (shen.newpv V2853) (let B (shen.newpv V2853) (do (shen.incinfs) (shen.th* Y B V2852 V2853 (freeze (bind X&& (shen.placeholder) V2853 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2853) (shen.lazyderef X V2853) (shen.lazyderef Z V2853)) V2853 (freeze (shen.th* W V2851 (cons (cons X&& (cons : (cons B ()))) V2852) V2853 V2854))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2759 (shen.lazyderef V2850 V2853) (if (cons? V2759) (let V2760 (shen.lazyderef (hd V2759) V2853) (if (= open V2760) (let V2761 (shen.lazyderef (tl V2759) V2853) (if (cons? V2761) (let FileName (hd V2761) (let V2762 (shen.lazyderef (tl V2761) V2853) (if (cons? V2762) (let Direction2692 (hd V2762) (let V2763 (shen.lazyderef (tl V2762) V2853) (if (= () V2763) (let V2764 (shen.lazyderef V2851 V2853) (if (cons? V2764) (let V2765 (shen.lazyderef (hd V2764) V2853) (if (= stream V2765) (let V2766 (shen.lazyderef (tl V2764) V2853) (if (cons? V2766) (let Direction (hd V2766) (let V2767 (shen.lazyderef (tl V2766) V2853) (if (= () V2767) (do (shen.incinfs) (unify! Direction Direction2692 V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* FileName string V2852 V2853 V2854)))))) (if (shen.pvar? V2767) (do (shen.bindv V2767 () V2853) (let Result (do (shen.incinfs) (unify! Direction Direction2692 V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* FileName string V2852 V2853 V2854)))))) (do (shen.unbindv V2767 V2853) Result))) false)))) (if (shen.pvar? V2766) (let Direction (shen.newpv V2853) (do (shen.bindv V2766 (cons Direction ()) V2853) (let Result (do (shen.incinfs) (unify! Direction Direction2692 V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* FileName string V2852 V2853 V2854)))))) (do (shen.unbindv V2766 V2853) Result)))) false))) (if (shen.pvar? V2765) (do (shen.bindv V2765 stream V2853) (let Result (let V2768 (shen.lazyderef (tl V2764) V2853) (if (cons? V2768) (let Direction (hd V2768) (let V2769 (shen.lazyderef (tl V2768) V2853) (if (= () V2769) (do (shen.incinfs) (unify! Direction Direction2692 V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* FileName string V2852 V2853 V2854)))))) (if (shen.pvar? V2769) (do (shen.bindv V2769 () V2853) (let Result (do (shen.incinfs) (unify! Direction Direction2692 V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* FileName string V2852 V2853 V2854)))))) (do (shen.unbindv V2769 V2853) Result))) false)))) (if (shen.pvar? V2768) (let Direction (shen.newpv V2853) (do (shen.bindv V2768 (cons Direction ()) V2853) (let Result (do (shen.incinfs) (unify! Direction Direction2692 V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* FileName string V2852 V2853 V2854)))))) (do (shen.unbindv V2768 V2853) Result)))) false))) (do (shen.unbindv V2765 V2853) Result))) false))) (if (shen.pvar? V2764) (let Direction (shen.newpv V2853) (do (shen.bindv V2764 (cons stream (cons Direction ())) V2853) (let Result (do (shen.incinfs) (unify! Direction Direction2692 V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* FileName string V2852 V2853 V2854)))))) (do (shen.unbindv V2764 V2853) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2770 (shen.lazyderef V2850 V2853) (if (cons? V2770) (let V2771 (shen.lazyderef (hd V2770) V2853) (if (= type V2771) (let V2772 (shen.lazyderef (tl V2770) V2853) (if (cons? V2772) (let X (hd V2772) (let V2773 (shen.lazyderef (tl V2772) V2853) (if (cons? V2773) (let A (hd V2773) (let V2774 (shen.lazyderef (tl V2773) V2853) (if (= () V2774) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (unify A V2851 V2853 (freeze (shen.th* X A V2852 V2853 V2854)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2775 (shen.lazyderef V2850 V2853) (if (cons? V2775) (let V2776 (shen.lazyderef (hd V2775) V2853) (if (= input+ V2776) (let V2777 (shen.lazyderef (tl V2775) V2853) (if (cons? V2777) (let A (hd V2777) (let V2778 (shen.lazyderef (tl V2777) V2853) (if (cons? V2778) (let Stream (hd V2778) (let V2779 (shen.lazyderef (tl V2778) V2853) (if (= () V2779) (let C (shen.newpv V2853) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2853)) V2853 (freeze (unify V2851 C V2853 (freeze (shen.th* Stream (cons stream (cons in ())) V2852 V2853 V2854))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2780 (shen.lazyderef V2850 V2853) (if (cons? V2780) (let V2781 (shen.lazyderef (hd V2780) V2853) (if (= set V2781) (let V2782 (shen.lazyderef (tl V2780) V2853) (if (cons? V2782) (let Var (hd V2782) (let V2783 (shen.lazyderef (tl V2782) V2853) (if (cons? V2783) (let Val (hd V2783) (let V2784 (shen.lazyderef (tl V2783) V2853) (if (= () V2784) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (shen.th* Var symbol V2852 V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* (cons value (cons Var ())) V2851 V2852 V2853 (freeze (shen.th* Val V2851 V2852 V2853 V2854)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2785 (shen.lazyderef V2850 V2853) (if (cons? V2785) (let V2786 (shen.lazyderef (hd V2785) V2853) (if (= shen.<-sem V2786) (let V2787 (shen.lazyderef (tl V2785) V2853) (if (cons? V2787) (let F (hd V2787) (let V2788 (shen.lazyderef (tl V2787) V2853) (if (= () V2788) (let A (shen.newpv V2853) (let F&& (shen.newpv V2853) (let B (shen.newpv V2853) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2852 V2853 (freeze (cut Throwcontrol V2853 (freeze (bind F&& (concat && (shen.lazyderef F V2853)) V2853 (freeze (cut Throwcontrol V2853 (freeze (shen.th* F&& V2851 (cons (cons F&& (cons : (cons B ()))) V2852) V2853 V2854))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2789 (shen.lazyderef V2850 V2853) (if (cons? V2789) (let V2790 (shen.lazyderef (hd V2789) V2853) (if (= fail V2790) (let V2791 (shen.lazyderef (tl V2789) V2853) (if (= () V2791) (let V2792 (shen.lazyderef V2851 V2853) (if (= symbol V2792) (do (shen.incinfs) (thaw V2854)) (if (shen.pvar? V2792) (do (shen.bindv V2792 symbol V2853) (let Result (do (shen.incinfs) (thaw V2854)) (do (shen.unbindv V2792 V2853) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2853) (do (shen.incinfs) (shen.t*-hyps V2852 NewHyp V2853 (freeze (shen.th* V2850 V2851 NewHyp V2853 V2854))))) (if (= Case false) (let Case (let V2793 (shen.lazyderef V2850 V2853) (if (cons? V2793) (let V2794 (shen.lazyderef (hd V2793) V2853) (if (= define V2794) (let V2795 (shen.lazyderef (tl V2793) V2853) (if (cons? V2795) (let F (hd V2795) (let X (tl V2795) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (shen.t*-def (cons define (cons F X)) V2851 V2852 V2853 V2854)))))) false)) false)) false)) (if (= Case false) (let Case (let V2796 (shen.lazyderef V2850 V2853) (if (cons? V2796) (let V2797 (shen.lazyderef (hd V2796) V2853) (if (= defcc V2797) (let V2798 (shen.lazyderef (tl V2796) V2853) (if (cons? V2798) (let F (hd V2798) (let X (tl V2798) (do (shen.incinfs) (cut Throwcontrol V2853 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2851 V2852 V2853 V2854)))))) false)) false)) false)) (if (= Case false) (let Case (let V2799 (shen.lazyderef V2850 V2853) (if (cons? V2799) (let V2800 (shen.lazyderef (hd V2799) V2853) (if (= defmacro V2800) (let V2801 (shen.lazyderef V2851 V2853) (if (= unit V2801) (do (shen.incinfs) (cut Throwcontrol V2853 V2854)) (if (shen.pvar? V2801) (do (shen.bindv V2801 unit V2853) (let Result (do (shen.incinfs) (cut Throwcontrol V2853 V2854)) (do (shen.unbindv V2801 V2853) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2802 (shen.lazyderef V2850 V2853) (if (cons? V2802) (let V2803 (shen.lazyderef (hd V2802) V2853) (if (= shen.process-datatype V2803) (let V2804 (shen.lazyderef V2851 V2853) (if (= symbol V2804) (do (shen.incinfs) (thaw V2854)) (if (shen.pvar? V2804) (do (shen.bindv V2804 symbol V2853) (let Result (do (shen.incinfs) (thaw V2854)) (do (shen.unbindv V2804 V2853) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2805 (shen.lazyderef V2850 V2853) (if (cons? V2805) (let V2806 (shen.lazyderef (hd V2805) V2853) (if (= shen.synonyms-help V2806) (let V2807 (shen.lazyderef V2851 V2853) (if (= symbol V2807) (do (shen.incinfs) (thaw V2854)) (if (shen.pvar? V2807) (do (shen.bindv V2807 symbol V2853) (let Result (do (shen.incinfs) (thaw V2854)) (do (shen.unbindv V2807 V2853) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2853) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2853 (freeze (shen.udefs* (cons V2850 (cons : (cons V2851 ()))) V2852 Datatypes V2853 V2854))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2855 V2856 V2857 V2858) (let Case (let V2607 (shen.lazyderef V2855 V2857) (if (cons? V2607) (let V2608 (shen.lazyderef (hd V2607) V2857) (if (cons? V2608) (let V2609 (shen.lazyderef (hd V2608) V2857) (if (cons? V2609) (let V2610 (shen.lazyderef (hd V2609) V2857) (if (= cons V2610) (let V2611 (shen.lazyderef (tl V2609) V2857) (if (cons? V2611) (let X (hd V2611) (let V2612 (shen.lazyderef (tl V2611) V2857) (if (cons? V2612) (let Y (hd V2612) (let V2613 (shen.lazyderef (tl V2612) V2857) (if (= () V2613) (let V2614 (shen.lazyderef (tl V2608) V2857) (if (cons? V2614) (let V2615 (shen.lazyderef (hd V2614) V2857) (if (= : V2615) (let V2616 (shen.lazyderef (tl V2614) V2857) (if (cons? V2616) (let V2617 (shen.lazyderef (hd V2616) V2857) (if (cons? V2617) (let V2618 (shen.lazyderef (hd V2617) V2857) (if (= list V2618) (let V2619 (shen.lazyderef (tl V2617) V2857) (if (cons? V2619) (let A (hd V2619) (let V2620 (shen.lazyderef (tl V2619) V2857) (if (= () V2620) (let V2621 (shen.lazyderef (tl V2616) V2857) (if (= () V2621) (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2621) (do (shen.bindv V2621 () V2857) (let Result (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2621 V2857) Result))) false))) (if (shen.pvar? V2620) (do (shen.bindv V2620 () V2857) (let Result (let V2622 (shen.lazyderef (tl V2616) V2857) (if (= () V2622) (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2622) (do (shen.bindv V2622 () V2857) (let Result (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2622 V2857) Result))) false))) (do (shen.unbindv V2620 V2857) Result))) false)))) (if (shen.pvar? V2619) (let A (shen.newpv V2857) (do (shen.bindv V2619 (cons A ()) V2857) (let Result (let V2623 (shen.lazyderef (tl V2616) V2857) (if (= () V2623) (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2623) (do (shen.bindv V2623 () V2857) (let Result (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2623 V2857) Result))) false))) (do (shen.unbindv V2619 V2857) Result)))) false))) (if (shen.pvar? V2618) (do (shen.bindv V2618 list V2857) (let Result (let V2624 (shen.lazyderef (tl V2617) V2857) (if (cons? V2624) (let A (hd V2624) (let V2625 (shen.lazyderef (tl V2624) V2857) (if (= () V2625) (let V2626 (shen.lazyderef (tl V2616) V2857) (if (= () V2626) (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2626) (do (shen.bindv V2626 () V2857) (let Result (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2626 V2857) Result))) false))) (if (shen.pvar? V2625) (do (shen.bindv V2625 () V2857) (let Result (let V2627 (shen.lazyderef (tl V2616) V2857) (if (= () V2627) (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2627) (do (shen.bindv V2627 () V2857) (let Result (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2627 V2857) Result))) false))) (do (shen.unbindv V2625 V2857) Result))) false)))) (if (shen.pvar? V2624) (let A (shen.newpv V2857) (do (shen.bindv V2624 (cons A ()) V2857) (let Result (let V2628 (shen.lazyderef (tl V2616) V2857) (if (= () V2628) (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2628) (do (shen.bindv V2628 () V2857) (let Result (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2628 V2857) Result))) false))) (do (shen.unbindv V2624 V2857) Result)))) false))) (do (shen.unbindv V2618 V2857) Result))) false))) (if (shen.pvar? V2617) (let A (shen.newpv V2857) (do (shen.bindv V2617 (cons list (cons A ())) V2857) (let Result (let V2629 (shen.lazyderef (tl V2616) V2857) (if (= () V2629) (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2629) (do (shen.bindv V2629 () V2857) (let Result (let Hyp (tl V2607) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons list (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2629 V2857) Result))) false))) (do (shen.unbindv V2617 V2857) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2630 (shen.lazyderef V2855 V2857) (if (cons? V2630) (let V2631 (shen.lazyderef (hd V2630) V2857) (if (cons? V2631) (let V2632 (shen.lazyderef (hd V2631) V2857) (if (cons? V2632) (let V2633 (shen.lazyderef (hd V2632) V2857) (if (= @p V2633) (let V2634 (shen.lazyderef (tl V2632) V2857) (if (cons? V2634) (let X (hd V2634) (let V2635 (shen.lazyderef (tl V2634) V2857) (if (cons? V2635) (let Y (hd V2635) (let V2636 (shen.lazyderef (tl V2635) V2857) (if (= () V2636) (let V2637 (shen.lazyderef (tl V2631) V2857) (if (cons? V2637) (let V2638 (shen.lazyderef (hd V2637) V2857) (if (= : V2638) (let V2639 (shen.lazyderef (tl V2637) V2857) (if (cons? V2639) (let V2640 (shen.lazyderef (hd V2639) V2857) (if (cons? V2640) (let A (hd V2640) (let V2641 (shen.lazyderef (tl V2640) V2857) (if (cons? V2641) (let V2642 (shen.lazyderef (hd V2641) V2857) (if (= * V2642) (let V2643 (shen.lazyderef (tl V2641) V2857) (if (cons? V2643) (let B (hd V2643) (let V2644 (shen.lazyderef (tl V2643) V2857) (if (= () V2644) (let V2645 (shen.lazyderef (tl V2639) V2857) (if (= () V2645) (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2645) (do (shen.bindv V2645 () V2857) (let Result (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2645 V2857) Result))) false))) (if (shen.pvar? V2644) (do (shen.bindv V2644 () V2857) (let Result (let V2646 (shen.lazyderef (tl V2639) V2857) (if (= () V2646) (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2646) (do (shen.bindv V2646 () V2857) (let Result (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2646 V2857) Result))) false))) (do (shen.unbindv V2644 V2857) Result))) false)))) (if (shen.pvar? V2643) (let B (shen.newpv V2857) (do (shen.bindv V2643 (cons B ()) V2857) (let Result (let V2647 (shen.lazyderef (tl V2639) V2857) (if (= () V2647) (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2647) (do (shen.bindv V2647 () V2857) (let Result (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2647 V2857) Result))) false))) (do (shen.unbindv V2643 V2857) Result)))) false))) (if (shen.pvar? V2642) (do (shen.bindv V2642 * V2857) (let Result (let V2648 (shen.lazyderef (tl V2641) V2857) (if (cons? V2648) (let B (hd V2648) (let V2649 (shen.lazyderef (tl V2648) V2857) (if (= () V2649) (let V2650 (shen.lazyderef (tl V2639) V2857) (if (= () V2650) (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2650) (do (shen.bindv V2650 () V2857) (let Result (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2650 V2857) Result))) false))) (if (shen.pvar? V2649) (do (shen.bindv V2649 () V2857) (let Result (let V2651 (shen.lazyderef (tl V2639) V2857) (if (= () V2651) (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2651) (do (shen.bindv V2651 () V2857) (let Result (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2651 V2857) Result))) false))) (do (shen.unbindv V2649 V2857) Result))) false)))) (if (shen.pvar? V2648) (let B (shen.newpv V2857) (do (shen.bindv V2648 (cons B ()) V2857) (let Result (let V2652 (shen.lazyderef (tl V2639) V2857) (if (= () V2652) (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2652) (do (shen.bindv V2652 () V2857) (let Result (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2652 V2857) Result))) false))) (do (shen.unbindv V2648 V2857) Result)))) false))) (do (shen.unbindv V2642 V2857) Result))) false))) (if (shen.pvar? V2641) (let B (shen.newpv V2857) (do (shen.bindv V2641 (cons * (cons B ())) V2857) (let Result (let V2653 (shen.lazyderef (tl V2639) V2857) (if (= () V2653) (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2653) (do (shen.bindv V2653 () V2857) (let Result (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2653 V2857) Result))) false))) (do (shen.unbindv V2641 V2857) Result)))) false)))) (if (shen.pvar? V2640) (let A (shen.newpv V2857) (let B (shen.newpv V2857) (do (shen.bindv V2640 (cons A (cons * (cons B ()))) V2857) (let Result (let V2654 (shen.lazyderef (tl V2639) V2857) (if (= () V2654) (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2654) (do (shen.bindv V2654 () V2857) (let Result (let Hyp (tl V2630) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (shen.lazyderef B V2857) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2654 V2857) Result))) false))) (do (shen.unbindv V2640 V2857) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2655 (shen.lazyderef V2855 V2857) (if (cons? V2655) (let V2656 (shen.lazyderef (hd V2655) V2857) (if (cons? V2656) (let V2657 (shen.lazyderef (hd V2656) V2857) (if (cons? V2657) (let V2658 (shen.lazyderef (hd V2657) V2857) (if (= @v V2658) (let V2659 (shen.lazyderef (tl V2657) V2857) (if (cons? V2659) (let X (hd V2659) (let V2660 (shen.lazyderef (tl V2659) V2857) (if (cons? V2660) (let Y (hd V2660) (let V2661 (shen.lazyderef (tl V2660) V2857) (if (= () V2661) (let V2662 (shen.lazyderef (tl V2656) V2857) (if (cons? V2662) (let V2663 (shen.lazyderef (hd V2662) V2857) (if (= : V2663) (let V2664 (shen.lazyderef (tl V2662) V2857) (if (cons? V2664) (let V2665 (shen.lazyderef (hd V2664) V2857) (if (cons? V2665) (let V2666 (shen.lazyderef (hd V2665) V2857) (if (= vector V2666) (let V2667 (shen.lazyderef (tl V2665) V2857) (if (cons? V2667) (let A (hd V2667) (let V2668 (shen.lazyderef (tl V2667) V2857) (if (= () V2668) (let V2669 (shen.lazyderef (tl V2664) V2857) (if (= () V2669) (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2669) (do (shen.bindv V2669 () V2857) (let Result (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2669 V2857) Result))) false))) (if (shen.pvar? V2668) (do (shen.bindv V2668 () V2857) (let Result (let V2670 (shen.lazyderef (tl V2664) V2857) (if (= () V2670) (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2670) (do (shen.bindv V2670 () V2857) (let Result (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2670 V2857) Result))) false))) (do (shen.unbindv V2668 V2857) Result))) false)))) (if (shen.pvar? V2667) (let A (shen.newpv V2857) (do (shen.bindv V2667 (cons A ()) V2857) (let Result (let V2671 (shen.lazyderef (tl V2664) V2857) (if (= () V2671) (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2671) (do (shen.bindv V2671 () V2857) (let Result (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2671 V2857) Result))) false))) (do (shen.unbindv V2667 V2857) Result)))) false))) (if (shen.pvar? V2666) (do (shen.bindv V2666 vector V2857) (let Result (let V2672 (shen.lazyderef (tl V2665) V2857) (if (cons? V2672) (let A (hd V2672) (let V2673 (shen.lazyderef (tl V2672) V2857) (if (= () V2673) (let V2674 (shen.lazyderef (tl V2664) V2857) (if (= () V2674) (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2674) (do (shen.bindv V2674 () V2857) (let Result (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2674 V2857) Result))) false))) (if (shen.pvar? V2673) (do (shen.bindv V2673 () V2857) (let Result (let V2675 (shen.lazyderef (tl V2664) V2857) (if (= () V2675) (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2675) (do (shen.bindv V2675 () V2857) (let Result (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2675 V2857) Result))) false))) (do (shen.unbindv V2673 V2857) Result))) false)))) (if (shen.pvar? V2672) (let A (shen.newpv V2857) (do (shen.bindv V2672 (cons A ()) V2857) (let Result (let V2676 (shen.lazyderef (tl V2664) V2857) (if (= () V2676) (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2676) (do (shen.bindv V2676 () V2857) (let Result (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2676 V2857) Result))) false))) (do (shen.unbindv V2672 V2857) Result)))) false))) (do (shen.unbindv V2666 V2857) Result))) false))) (if (shen.pvar? V2665) (let A (shen.newpv V2857) (do (shen.bindv V2665 (cons vector (cons A ())) V2857) (let Result (let V2677 (shen.lazyderef (tl V2664) V2857) (if (= () V2677) (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2677) (do (shen.bindv V2677 () V2857) (let Result (let Hyp (tl V2655) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons (shen.lazyderef A V2857) ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons (cons vector (cons (shen.lazyderef A V2857) ())) ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2677 V2857) Result))) false))) (do (shen.unbindv V2665 V2857) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2678 (shen.lazyderef V2855 V2857) (if (cons? V2678) (let V2679 (shen.lazyderef (hd V2678) V2857) (if (cons? V2679) (let V2680 (shen.lazyderef (hd V2679) V2857) (if (cons? V2680) (let V2681 (shen.lazyderef (hd V2680) V2857) (if (= @s V2681) (let V2682 (shen.lazyderef (tl V2680) V2857) (if (cons? V2682) (let X (hd V2682) (let V2683 (shen.lazyderef (tl V2682) V2857) (if (cons? V2683) (let Y (hd V2683) (let V2684 (shen.lazyderef (tl V2683) V2857) (if (= () V2684) (let V2685 (shen.lazyderef (tl V2679) V2857) (if (cons? V2685) (let V2686 (shen.lazyderef (hd V2685) V2857) (if (= : V2686) (let V2687 (shen.lazyderef (tl V2685) V2857) (if (cons? V2687) (let V2688 (shen.lazyderef (hd V2687) V2857) (if (= string V2688) (let V2689 (shen.lazyderef (tl V2687) V2857) (if (= () V2689) (let Hyp (tl V2678) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons string ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2689) (do (shen.bindv V2689 () V2857) (let Result (let Hyp (tl V2678) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons string ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2689 V2857) Result))) false))) (if (shen.pvar? V2688) (do (shen.bindv V2688 string V2857) (let Result (let V2690 (shen.lazyderef (tl V2687) V2857) (if (= () V2690) (let Hyp (tl V2678) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons string ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (if (shen.pvar? V2690) (do (shen.bindv V2690 () V2857) (let Result (let Hyp (tl V2678) (do (shen.incinfs) (bind V2856 (cons (cons (shen.lazyderef X V2857) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2857) (cons : (cons string ()))) (shen.lazyderef Hyp V2857))) V2857 V2858))) (do (shen.unbindv V2690 V2857) Result))) false))) (do (shen.unbindv V2688 V2857) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2691 (shen.lazyderef V2855 V2857) (if (cons? V2691) (let X (hd V2691) (let Hyp (tl V2691) (let NewHyps (shen.newpv V2857) (do (shen.incinfs) (bind V2856 (cons (shen.lazyderef X V2857) (shen.lazyderef NewHyps V2857)) V2857 (freeze (shen.t*-hyps Hyp NewHyps V2857 V2858))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2871 V2872 V2873 V2874) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2871 V2873)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2872 V2873) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2874))))))))) (true (thaw V2874))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2875) (cond ((and (cons? V2875) (and (cons? (tl V2875)) (and (= : (hd (tl V2875))) (and (cons? (tl (tl V2875))) (= () (tl (tl (tl V2875)))))))) (shen.prhush (shen.app (hd V2875) (cn " : " (shen.app (hd (tl (tl V2875))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2875 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2878 V2879) (cond ((= () V2878) shen.skip) ((cons? V2878) (do (shen.prhush (shen.app V2879 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2878)) (do (nl 1) (shen.show-assumptions (tl V2878) (+ V2879 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (do (read-byte (stinput)) (read-byte (stinput))) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2880) (cons? (assoc V2880 (value shen.*signedfuncs*))))

(defun shen.sigf (V2881) (concat shen.type-signature-of- V2881))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2882 V2883 V2884 V2885) (let Case (let V2594 (shen.lazyderef V2883 V2884) (if (= number V2594) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2882 V2884)) V2884 V2885)) (if (shen.pvar? V2594) (do (shen.bindv V2594 number V2884) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2882 V2884)) V2884 V2885)) (do (shen.unbindv V2594 V2884) Result))) false))) (if (= Case false) (let Case (let V2595 (shen.lazyderef V2883 V2884) (if (= boolean V2595) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2882 V2884)) V2884 V2885)) (if (shen.pvar? V2595) (do (shen.bindv V2595 boolean V2884) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2882 V2884)) V2884 V2885)) (do (shen.unbindv V2595 V2884) Result))) false))) (if (= Case false) (let Case (let V2596 (shen.lazyderef V2883 V2884) (if (= string V2596) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2882 V2884)) V2884 V2885)) (if (shen.pvar? V2596) (do (shen.bindv V2596 string V2884) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2882 V2884)) V2884 V2885)) (do (shen.unbindv V2596 V2884) Result))) false))) (if (= Case false) (let Case (let V2597 (shen.lazyderef V2883 V2884) (if (= symbol V2597) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2882 V2884)) V2884 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2882 V2884))) V2884 V2885)))) (if (shen.pvar? V2597) (do (shen.bindv V2597 symbol V2884) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2882 V2884)) V2884 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2882 V2884))) V2884 V2885)))) (do (shen.unbindv V2597 V2884) Result))) false))) (if (= Case false) (let V2598 (shen.lazyderef V2882 V2884) (if (= () V2598) (let V2599 (shen.lazyderef V2883 V2884) (if (cons? V2599) (let V2600 (shen.lazyderef (hd V2599) V2884) (if (= list V2600) (let V2601 (shen.lazyderef (tl V2599) V2884) (if (cons? V2601) (let A (hd V2601) (let V2602 (shen.lazyderef (tl V2601) V2884) (if (= () V2602) (do (shen.incinfs) (thaw V2885)) (if (shen.pvar? V2602) (do (shen.bindv V2602 () V2884) (let Result (do (shen.incinfs) (thaw V2885)) (do (shen.unbindv V2602 V2884) Result))) false)))) (if (shen.pvar? V2601) (let A (shen.newpv V2884) (do (shen.bindv V2601 (cons A ()) V2884) (let Result (do (shen.incinfs) (thaw V2885)) (do (shen.unbindv V2601 V2884) Result)))) false))) (if (shen.pvar? V2600) (do (shen.bindv V2600 list V2884) (let Result (let V2603 (shen.lazyderef (tl V2599) V2884) (if (cons? V2603) (let A (hd V2603) (let V2604 (shen.lazyderef (tl V2603) V2884) (if (= () V2604) (do (shen.incinfs) (thaw V2885)) (if (shen.pvar? V2604) (do (shen.bindv V2604 () V2884) (let Result (do (shen.incinfs) (thaw V2885)) (do (shen.unbindv V2604 V2884) Result))) false)))) (if (shen.pvar? V2603) (let A (shen.newpv V2884) (do (shen.bindv V2603 (cons A ()) V2884) (let Result (do (shen.incinfs) (thaw V2885)) (do (shen.unbindv V2603 V2884) Result)))) false))) (do (shen.unbindv V2600 V2884) Result))) false))) (if (shen.pvar? V2599) (let A (shen.newpv V2884) (do (shen.bindv V2599 (cons list (cons A ())) V2884) (let Result (do (shen.incinfs) (thaw V2885)) (do (shen.unbindv V2599 V2884) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2886 V2887 V2888 V2889 V2890) (let Case (let V2585 (shen.lazyderef V2888 V2889) (if (cons? V2585) (let V2586 (shen.lazyderef (hd V2585) V2889) (if (cons? V2586) (let Y (hd V2586) (let V2587 (shen.lazyderef (tl V2586) V2889) (if (cons? V2587) (let V2588 (shen.lazyderef (hd V2587) V2889) (if (= : V2588) (let V2589 (shen.lazyderef (tl V2587) V2889) (if (cons? V2589) (let B (hd V2589) (let V2590 (shen.lazyderef (tl V2589) V2889) (if (= () V2590) (do (shen.incinfs) (identical V2886 Y V2889 (freeze (unify! V2887 B V2889 V2890)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2591 (shen.lazyderef V2888 V2889) (if (cons? V2591) (let Hyp (tl V2591) (do (shen.incinfs) (shen.by_hypothesis V2886 V2887 Hyp V2889 V2890))) false)) Case)))

(defun shen.t*-def (V2891 V2892 V2893 V2894 V2895) (let V2579 (shen.lazyderef V2891 V2894) (if (cons? V2579) (let V2580 (shen.lazyderef (hd V2579) V2894) (if (= define V2580) (let V2581 (shen.lazyderef (tl V2579) V2894) (if (cons? V2581) (let F (hd V2581) (let X (tl V2581) (let E (shen.newpv V2894) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2892 V2893 V2894 V2895))))) false)) false)) false)))

(defun shen.t*-defh (V2896 V2897 V2898 V2899 V2900 V2901) (let V2575 (shen.lazyderef V2896 V2900) (if (cons? V2575) (let Sig (hd V2575) (let Rules (tl V2575) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2897 V2898 V2899 Rules V2900 V2901)))) false)))

(defun shen.t*-defhh (V2902 V2903 V2904 V2905 V2906 V2907 V2908 V2909) (do (shen.incinfs) (shen.t*-rules V2907 V2903 1 V2904 (cons (cons V2904 (cons : (cons V2903 ()))) V2906) V2908 (freeze (shen.memo V2904 V2902 V2905 V2908 V2909)))))

(defun shen.memo (V2910 V2911 V2912 V2913 V2914) (let Jnk (shen.newpv V2913) (do (shen.incinfs) (unify! V2912 V2911 V2913 (freeze (bind Jnk (declare (shen.lazyderef V2910 V2913) (shen.lazyderef V2912 V2913)) V2913 V2914))))))

(defun shen.<sig+rules> (V2919) (let Result (let Parse_shen.<signature> (shen.<signature> V2919) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2920) (cond ((and (cons? V2920) (and (cons? (tl V2920)) (and (= () (tl (tl V2920))) (= (hd V2920) protect)))) V2920) ((cons? V2920) (map shen.ue V2920)) ((variable? V2920) (concat && V2920)) (true V2920)))

(defun shen.ue-sig (V2921) (cond ((cons? V2921) (map shen.ue-sig V2921)) ((variable? V2921) (concat &&& V2921)) (true V2921)))

(defun shen.ues (V2926) (cond ((shen.ue? V2926) (cons V2926 ())) ((cons? V2926) (union (shen.ues (hd V2926)) (shen.ues (tl V2926)))) (true ())))

(defun shen.ue? (V2927) (and (symbol? V2927) (shen.ue-h? (str V2927))))

(defun shen.ue-h? (V2934) (cond ((and (shen.+string? V2934) (and (= "&" (pos V2934 0)) (and (shen.+string? (tlstr V2934)) (= "&" (pos (tlstr V2934) 0))))) true) (true false)))

(defun shen.t*-rules (V2935 V2936 V2937 V2938 V2939 V2940 V2941) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2550 (shen.lazyderef V2935 V2940) (if (= () V2550) (do (shen.incinfs) (thaw V2941)) false)) (if (= Case false) (let Case (let V2551 (shen.lazyderef V2935 V2940) (if (cons? V2551) (let V2552 (shen.lazyderef (hd V2551) V2940) (if (cons? V2552) (let V2553 (shen.lazyderef (hd V2552) V2940) (if (= () V2553) (let V2554 (shen.lazyderef (tl V2552) V2940) (if (cons? V2554) (let Action (hd V2554) (let V2555 (shen.lazyderef (tl V2554) V2940) (if (= () V2555) (let Rules (tl V2551) (let V2556 (shen.lazyderef V2936 V2940) (if (cons? V2556) (let V2557 (shen.lazyderef (hd V2556) V2940) (if (= --> V2557) (let V2558 (shen.lazyderef (tl V2556) V2940) (if (cons? V2558) (let A (hd V2558) (let V2559 (shen.lazyderef (tl V2558) V2940) (if (= () V2559) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2939 V2940 (freeze (cut Throwcontrol V2940 (freeze (shen.t*-rules Rules A (+ V2937 1) V2938 V2939 V2940 V2941)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2560 (shen.lazyderef V2935 V2940) (if (cons? V2560) (let Rule (hd V2560) (let Rules (tl V2560) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2936 V2939 V2940 (freeze (cut Throwcontrol V2940 (freeze (shen.t*-rules Rules V2936 (+ V2937 1) V2938 V2939 V2940 V2941)))))))) false)) (if (= Case false) (let Err (shen.newpv V2940) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2937 V2940) (cn " of " (shen.app (shen.lazyderef V2938 V2940) "" shen.a)) shen.a))) V2940 V2941))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2942 V2943 V2944 V2945 V2946) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2532 (shen.lazyderef V2942 V2945) (if (cons? V2532) (let V2533 (shen.lazyderef (hd V2532) V2945) (if (= () V2533) (let V2534 (shen.lazyderef (tl V2532) V2945) (if (cons? V2534) (let Action (hd V2534) (let V2535 (shen.lazyderef (tl V2534) V2945) (if (= () V2535) (do (shen.incinfs) (cut Throwcontrol V2945 (freeze (shen.t*-action (shen.curry Action) V2943 V2944 V2945 V2946)))) false))) false)) false)) false)) (if (= Case false) (let V2536 (shen.lazyderef V2942 V2945) (if (cons? V2536) (let V2537 (shen.lazyderef (hd V2536) V2945) (if (cons? V2537) (let Pattern (hd V2537) (let Patterns (tl V2537) (let V2538 (shen.lazyderef (tl V2536) V2945) (if (cons? V2538) (let Action (hd V2538) (let V2539 (shen.lazyderef (tl V2538) V2945) (if (= () V2539) (let V2540 (shen.lazyderef V2943 V2945) (if (cons? V2540) (let A (hd V2540) (let V2541 (shen.lazyderef (tl V2540) V2945) (if (cons? V2541) (let V2542 (shen.lazyderef (hd V2541) V2945) (if (= --> V2542) (let V2543 (shen.lazyderef (tl V2541) V2945) (if (cons? V2543) (let B (hd V2543) (let V2544 (shen.lazyderef (tl V2543) V2945) (if (= () V2544) (do (shen.incinfs) (shen.t*-pattern Pattern A V2945 (freeze (cut Throwcontrol V2945 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2944) V2945 V2946)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2947 V2948 V2949 V2950 V2951) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2509 (shen.lazyderef V2947 V2950) (if (cons? V2509) (let V2510 (shen.lazyderef (hd V2509) V2950) (if (= where V2510) (let V2511 (shen.lazyderef (tl V2509) V2950) (if (cons? V2511) (let P (hd V2511) (let V2512 (shen.lazyderef (tl V2511) V2950) (if (cons? V2512) (let Action (hd V2512) (let V2513 (shen.lazyderef (tl V2512) V2950) (if (= () V2513) (do (shen.incinfs) (cut Throwcontrol V2950 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2949 V2950 (freeze (cut Throwcontrol V2950 (freeze (shen.t*-action Action V2948 (cons (cons P (cons : (cons verified ()))) V2949) V2950 V2951)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2514 (shen.lazyderef V2947 V2950) (if (cons? V2514) (let V2515 (shen.lazyderef (hd V2514) V2950) (if (= shen.choicepoint! V2515) (let V2516 (shen.lazyderef (tl V2514) V2950) (if (cons? V2516) (let V2517 (shen.lazyderef (hd V2516) V2950) (if (cons? V2517) (let V2518 (shen.lazyderef (hd V2517) V2950) (if (cons? V2518) (let V2519 (shen.lazyderef (hd V2518) V2950) (if (= fail-if V2519) (let V2520 (shen.lazyderef (tl V2518) V2950) (if (cons? V2520) (let F (hd V2520) (let V2521 (shen.lazyderef (tl V2520) V2950) (if (= () V2521) (let V2522 (shen.lazyderef (tl V2517) V2950) (if (cons? V2522) (let Action (hd V2522) (let V2523 (shen.lazyderef (tl V2522) V2950) (if (= () V2523) (let V2524 (shen.lazyderef (tl V2516) V2950) (if (= () V2524) (do (shen.incinfs) (cut Throwcontrol V2950 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2948 V2949 V2950 V2951)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2525 (shen.lazyderef V2947 V2950) (if (cons? V2525) (let V2526 (shen.lazyderef (hd V2525) V2950) (if (= shen.choicepoint! V2526) (let V2527 (shen.lazyderef (tl V2525) V2950) (if (cons? V2527) (let Action (hd V2527) (let V2528 (shen.lazyderef (tl V2527) V2950) (if (= () V2528) (do (shen.incinfs) (cut Throwcontrol V2950 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2948 V2949 V2950 V2951)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2947 (cons : (cons V2948 ()))) V2949 V2950 V2951)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2952 V2953 V2954 V2955) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2954) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2952) Hyp V2954 (freeze (cut Throwcontrol V2954 (freeze (shen.t* (cons V2952 (cons : (cons V2953 ()))) Hyp V2954 V2955))))))))))

(defun shen.tms->hyp (V2956 V2957 V2958 V2959) (let Case (let V2493 (shen.lazyderef V2956 V2958) (if (= () V2493) (let V2494 (shen.lazyderef V2957 V2958) (if (= () V2494) (do (shen.incinfs) (thaw V2959)) (if (shen.pvar? V2494) (do (shen.bindv V2494 () V2958) (let Result (do (shen.incinfs) (thaw V2959)) (do (shen.unbindv V2494 V2958) Result))) false))) false)) (if (= Case false) (let V2495 (shen.lazyderef V2956 V2958) (if (cons? V2495) (let Tm2490 (hd V2495) (let Tms (tl V2495) (let V2496 (shen.lazyderef V2957 V2958) (if (cons? V2496) (let V2497 (shen.lazyderef (hd V2496) V2958) (if (cons? V2497) (let Tm (hd V2497) (let V2498 (shen.lazyderef (tl V2497) V2958) (if (cons? V2498) (let V2499 (shen.lazyderef (hd V2498) V2958) (if (= : V2499) (let V2500 (shen.lazyderef (tl V2498) V2958) (if (cons? V2500) (let A (hd V2500) (let V2501 (shen.lazyderef (tl V2500) V2958) (if (= () V2501) (let Hyp (tl V2496) (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959))))) (if (shen.pvar? V2501) (do (shen.bindv V2501 () V2958) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959))))) (do (shen.unbindv V2501 V2958) Result))) false)))) (if (shen.pvar? V2500) (let A (shen.newpv V2958) (do (shen.bindv V2500 (cons A ()) V2958) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959))))) (do (shen.unbindv V2500 V2958) Result)))) false))) (if (shen.pvar? V2499) (do (shen.bindv V2499 : V2958) (let Result (let V2502 (shen.lazyderef (tl V2498) V2958) (if (cons? V2502) (let A (hd V2502) (let V2503 (shen.lazyderef (tl V2502) V2958) (if (= () V2503) (let Hyp (tl V2496) (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959))))) (if (shen.pvar? V2503) (do (shen.bindv V2503 () V2958) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959))))) (do (shen.unbindv V2503 V2958) Result))) false)))) (if (shen.pvar? V2502) (let A (shen.newpv V2958) (do (shen.bindv V2502 (cons A ()) V2958) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959))))) (do (shen.unbindv V2502 V2958) Result)))) false))) (do (shen.unbindv V2499 V2958) Result))) false))) (if (shen.pvar? V2498) (let A (shen.newpv V2958) (do (shen.bindv V2498 (cons : (cons A ())) V2958) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959))))) (do (shen.unbindv V2498 V2958) Result)))) false)))) (if (shen.pvar? V2497) (let Tm (shen.newpv V2958) (let A (shen.newpv V2958) (do (shen.bindv V2497 (cons Tm (cons : (cons A ()))) V2958) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959))))) (do (shen.unbindv V2497 V2958) Result))))) false))) (if (shen.pvar? V2496) (let Tm (shen.newpv V2958) (let A (shen.newpv V2958) (let Hyp (shen.newpv V2958) (do (shen.bindv V2496 (cons (cons Tm (cons : (cons A ()))) Hyp) V2958) (let Result (do (shen.incinfs) (unify! Tm Tm2490 V2958 (freeze (shen.tms->hyp Tms Hyp V2958 V2959)))) (do (shen.unbindv V2496 V2958) Result)))))) false))))) false)) Case)))

(defun findall (V2960 V2961 V2962 V2963 V2964) (let B (shen.newpv V2963) (let A (shen.newpv V2963) (do (shen.incinfs) (bind A (gensym shen.a) V2963 (freeze (bind B (set (shen.lazyderef A V2963) ()) V2963 (freeze (shen.findallhelp V2960 V2961 V2962 A V2963 V2964)))))))))

(defun shen.findallhelp (V2965 V2966 V2967 V2968 V2969 V2970) (let Case (do (shen.incinfs) (call V2966 V2969 (freeze (shen.remember V2968 V2965 V2969 (freeze (fwhen false V2969 V2970)))))) (if (= Case false) (do (shen.incinfs) (bind V2967 (value (shen.lazyderef V2968 V2969)) V2969 V2970)) Case)))

(defun shen.remember (V2971 V2972 V2973 V2974) (let B (shen.newpv V2973) (do (shen.incinfs) (bind B (set (shen.deref V2971 V2973) (cons (shen.deref V2972 V2973) (value (shen.deref V2971 V2973)))) V2973 V2974))))

(defun shen.t*-defcc (V2975 V2976 V2977 V2978 V2979) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2466 (shen.lazyderef V2975 V2978) (if (cons? V2466) (let V2467 (shen.lazyderef (hd V2466) V2978) (if (= defcc V2467) (let V2468 (shen.lazyderef (tl V2466) V2978) (if (cons? V2468) (let F (hd V2468) (let V2469 (shen.lazyderef (tl V2468) V2978) (if (cons? V2469) (let V2470 (shen.lazyderef (hd V2469) V2978) (if (= { V2470) (let V2471 (shen.lazyderef (tl V2469) V2978) (if (cons? V2471) (let V2472 (shen.lazyderef (hd V2471) V2978) (if (cons? V2472) (let V2473 (shen.lazyderef (hd V2472) V2978) (if (= list V2473) (let V2474 (shen.lazyderef (tl V2472) V2978) (if (cons? V2474) (let A (hd V2474) (let V2475 (shen.lazyderef (tl V2474) V2978) (if (= () V2475) (let V2476 (shen.lazyderef (tl V2471) V2978) (if (cons? V2476) (let V2477 (shen.lazyderef (hd V2476) V2978) (if (= ==> V2477) (let V2478 (shen.lazyderef (tl V2476) V2978) (if (cons? V2478) (let B (hd V2478) (let V2479 (shen.lazyderef (tl V2478) V2978) (if (cons? V2479) (let V2480 (shen.lazyderef (hd V2479) V2978) (if (= } V2480) (let Rest (tl V2479) (let Rest& (shen.newpv V2978) (let Rest&& (shen.newpv V2978) (let Rules (shen.newpv V2978) (let ListA&& (shen.newpv V2978) (let B&& (shen.newpv V2978) (let Sig (shen.newpv V2978) (let Declare (shen.newpv V2978) (do (shen.incinfs) (bind Sig (shen.ue (cons (cons list (cons (shen.lazyderef A V2978) ())) (cons ==> (cons (shen.lazyderef B V2978) ())))) V2978 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2978)) V2978 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2978)))) V2978 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2978)) V2978 (freeze (bind Rest&& (shen.ue (shen.lazyderef Rest& V2978)) V2978 (freeze (shen.get-rules Rules Rest&& V2978 (freeze (cut Throwcontrol V2978 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2977) 1 V2978 (freeze (unify V2976 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2978 (freeze (bind Declare (declare (shen.lazyderef F V2978) (cons (cons list (cons (shen.lazyderef A V2978) ())) (cons ==> (cons (shen.lazyderef B V2978) ())))) V2978 V2979)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2980) (cond ((cons? V2980) (map shen.plug-wildcards V2980)) ((= V2980 _) (gensym (intern "X"))) (true V2980)))

(defun shen.get-rules (V2981 V2982 V2983 V2984) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2459 (shen.lazyderef V2981 V2983) (if (= () V2459) (let V2460 (shen.lazyderef V2982 V2983) (if (= () V2460) (do (shen.incinfs) (cut Throwcontrol V2983 V2984)) false)) (if (shen.pvar? V2459) (do (shen.bindv V2459 () V2983) (let Result (let V2461 (shen.lazyderef V2982 V2983) (if (= () V2461) (do (shen.incinfs) (cut Throwcontrol V2983 V2984)) false)) (do (shen.unbindv V2459 V2983) Result))) false))) (if (= Case false) (let V2462 (shen.lazyderef V2981 V2983) (if (cons? V2462) (let Rule (hd V2462) (let Rules (tl V2462) (let Other (shen.newpv V2983) (do (shen.incinfs) (shen.first-rule V2982 Rule Other V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.get-rules Rules Other V2983 V2984))))))))) (if (shen.pvar? V2462) (let Rule (shen.newpv V2983) (let Rules (shen.newpv V2983) (do (shen.bindv V2462 (cons Rule Rules) V2983) (let Result (let Other (shen.newpv V2983) (do (shen.incinfs) (shen.first-rule V2982 Rule Other V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.get-rules Rules Other V2983 V2984))))))) (do (shen.unbindv V2462 V2983) Result))))) false))) Case)))))

(defun shen.first-rule (V2985 V2986 V2987 V2988 V2989) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2452 (shen.lazyderef V2985 V2988) (if (cons? V2452) (let V2453 (shen.lazyderef (hd V2452) V2988) (if (= ; V2453) (let Other2447 (tl V2452) (let V2454 (shen.lazyderef V2986 V2988) (if (= () V2454) (do (shen.incinfs) (unify! V2987 Other2447 V2988 (freeze (cut Throwcontrol V2988 V2989)))) (if (shen.pvar? V2454) (do (shen.bindv V2454 () V2988) (let Result (do (shen.incinfs) (unify! V2987 Other2447 V2988 (freeze (cut Throwcontrol V2988 V2989)))) (do (shen.unbindv V2454 V2988) Result))) false)))) false)) false)) (if (= Case false) (let V2455 (shen.lazyderef V2985 V2988) (if (cons? V2455) (let X2448 (hd V2455) (let Rest (tl V2455) (let V2456 (shen.lazyderef V2986 V2988) (if (cons? V2456) (let X (hd V2456) (let Rule (tl V2456) (do (shen.incinfs) (unify! X X2448 V2988 (freeze (shen.first-rule Rest Rule V2987 V2988 V2989)))))) (if (shen.pvar? V2456) (let X (shen.newpv V2988) (let Rule (shen.newpv V2988) (do (shen.bindv V2456 (cons X Rule) V2988) (let Result (do (shen.incinfs) (unify! X X2448 V2988 (freeze (shen.first-rule Rest Rule V2987 V2988 V2989)))) (do (shen.unbindv V2456 V2988) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V2990 V2991 V2992 V2993 V2994 V2995 V2996 V2997) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2441 (shen.lazyderef V2991 V2996) (if (= () V2441) (do (shen.incinfs) (thaw V2997)) false)) (if (= Case false) (let V2442 (shen.lazyderef V2991 V2996) (if (cons? V2442) (let Rule (hd V2442) (let Rules (tl V2442) (let V2443 (shen.lazyderef V2992 V2996) (if (cons? V2443) (let V2444 (shen.lazyderef (hd V2443) V2996) (if (= list V2444) (let V2445 (shen.lazyderef (tl V2443) V2996) (if (cons? V2445) (let A (hd V2445) (let V2446 (shen.lazyderef (tl V2445) V2996) (if (= () V2446) (let M (shen.newpv V2996) (do (shen.incinfs) (shen.tc-rule V2990 Rule A V2993 V2994 V2995 V2996 (freeze (bind M (+ (shen.deref V2995 V2996) 1) V2996 (freeze (cut Throwcontrol V2996 (freeze (shen.tc-rules V2990 Rules (cons list (cons A ())) V2993 V2994 M V2996 V2997))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V2998 V2999 V3000 V3001 V3002 V3003 V3004 V3005) (let Case (do (shen.incinfs) (shen.check-defcc-rule V2999 V3000 V3001 V3002 V3004 V3005)) (if (= Case false) (let Err (shen.newpv V3004) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3003 V3004) (cn " of " (shen.app (shen.lazyderef V2998 V3004) "" shen.a)) shen.a))) V3004 V3005))) Case)))

(defun shen.check-defcc-rule (V3006 V3007 V3008 V3009 V3010 V3011) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V3010) (let Semantics (shen.newpv V3010) (let SynHyps (shen.newpv V3010) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V3006 V3010 (freeze (cut Throwcontrol V3010 (freeze (shen.syntax-hyps Syntax V3009 SynHyps V3007 V3010 (freeze (cut Throwcontrol V3010 (freeze (shen.syntax-check Syntax V3007 SynHyps V3010 (freeze (cut Throwcontrol V3010 (freeze (shen.semantics-check Semantics V3008 SynHyps V3010 V3011))))))))))))))))))))

(defun shen.syntax-hyps (V3012 V3013 V3014 V3015 V3016 V3017) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2414 (shen.lazyderef V3012 V3016) (if (= () V2414) (do (shen.incinfs) (unify! V3014 V3013 V3016 V3017)) false)) (if (= Case false) (let Case (let V2415 (shen.lazyderef V3012 V3016) (if (cons? V2415) (let X2408 (hd V2415) (let Y (tl V2415) (let V2416 (shen.lazyderef V3014 V3016) (if (cons? V2416) (let V2417 (shen.lazyderef (hd V2416) V3016) (if (cons? V2417) (let X (hd V2417) (let V2418 (shen.lazyderef (tl V2417) V3016) (if (cons? V2418) (let V2419 (shen.lazyderef (hd V2418) V3016) (if (= : V2419) (let V2420 (shen.lazyderef (tl V2418) V3016) (if (cons? V2420) (let A2409 (hd V2420) (let V2421 (shen.lazyderef (tl V2420) V3016) (if (= () V2421) (let SynHyps (tl V2416) (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017))))))))))) (if (shen.pvar? V2421) (do (shen.bindv V2421 () V3016) (let Result (let SynHyps (tl V2416) (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017))))))))))) (do (shen.unbindv V2421 V3016) Result))) false)))) (if (shen.pvar? V2420) (let A2409 (shen.newpv V3016) (do (shen.bindv V2420 (cons A2409 ()) V3016) (let Result (let SynHyps (tl V2416) (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017))))))))))) (do (shen.unbindv V2420 V3016) Result)))) false))) (if (shen.pvar? V2419) (do (shen.bindv V2419 : V3016) (let Result (let V2422 (shen.lazyderef (tl V2418) V3016) (if (cons? V2422) (let A2409 (hd V2422) (let V2423 (shen.lazyderef (tl V2422) V3016) (if (= () V2423) (let SynHyps (tl V2416) (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017))))))))))) (if (shen.pvar? V2423) (do (shen.bindv V2423 () V3016) (let Result (let SynHyps (tl V2416) (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017))))))))))) (do (shen.unbindv V2423 V3016) Result))) false)))) (if (shen.pvar? V2422) (let A2409 (shen.newpv V3016) (do (shen.bindv V2422 (cons A2409 ()) V3016) (let Result (let SynHyps (tl V2416) (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017))))))))))) (do (shen.unbindv V2422 V3016) Result)))) false))) (do (shen.unbindv V2419 V3016) Result))) false))) (if (shen.pvar? V2418) (let A2409 (shen.newpv V3016) (do (shen.bindv V2418 (cons : (cons A2409 ())) V3016) (let Result (let SynHyps (tl V2416) (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017))))))))))) (do (shen.unbindv V2418 V3016) Result)))) false)))) (if (shen.pvar? V2417) (let X (shen.newpv V3016) (let A2409 (shen.newpv V3016) (do (shen.bindv V2417 (cons X (cons : (cons A2409 ()))) V3016) (let Result (let SynHyps (tl V2416) (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017))))))))))) (do (shen.unbindv V2417 V3016) Result))))) false))) (if (shen.pvar? V2416) (let X (shen.newpv V3016) (let A2409 (shen.newpv V3016) (let SynHyps (shen.newpv V3016) (do (shen.bindv V2416 (cons (cons X (cons : (cons A2409 ()))) SynHyps) V3016) (let Result (do (shen.incinfs) (unify! V3015 A2409 V3016 (freeze (unify! X X2408 V3016 (freeze (fwhen (shen.ue? (shen.deref X V3016)) V3016 (freeze (cut Throwcontrol V3016 (freeze (shen.syntax-hyps Y V3013 SynHyps V3015 V3016 V3017)))))))))) (do (shen.unbindv V2416 V3016) Result)))))) false))))) false)) (if (= Case false) (let V2424 (shen.lazyderef V3012 V3016) (if (cons? V2424) (let Y (tl V2424) (do (shen.incinfs) (shen.syntax-hyps Y V3013 V3014 V3015 V3016 V3017))) false)) Case)) Case)))))

(defun shen.get-syntax+semantics (V3018 V3019 V3020 V3021 V3022) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2380 (shen.lazyderef V3018 V3021) (if (= () V2380) (let V2381 (shen.lazyderef V3020 V3021) (if (cons? V2381) (let V2382 (shen.lazyderef (hd V2381) V3021) (if (= := V2382) (let V2383 (shen.lazyderef (tl V2381) V3021) (if (cons? V2383) (let Semantics (hd V2383) (let V2384 (shen.lazyderef (tl V2383) V3021) (if (= () V2384) (do (shen.incinfs) (cut Throwcontrol V3021 (freeze (bind V3019 (shen.lazyderef Semantics V3021) V3021 V3022)))) false))) false)) false)) false)) (if (shen.pvar? V2380) (do (shen.bindv V2380 () V3021) (let Result (let V2385 (shen.lazyderef V3020 V3021) (if (cons? V2385) (let V2386 (shen.lazyderef (hd V2385) V3021) (if (= := V2386) (let V2387 (shen.lazyderef (tl V2385) V3021) (if (cons? V2387) (let Semantics (hd V2387) (let V2388 (shen.lazyderef (tl V2387) V3021) (if (= () V2388) (do (shen.incinfs) (cut Throwcontrol V3021 (freeze (bind V3019 (shen.lazyderef Semantics V3021) V3021 V3022)))) false))) false)) false)) false)) (do (shen.unbindv V2380 V3021) Result))) false))) (if (= Case false) (let Case (let V2389 (shen.lazyderef V3018 V3021) (if (= () V2389) (let V2390 (shen.lazyderef V3020 V3021) (if (cons? V2390) (let V2391 (shen.lazyderef (hd V2390) V3021) (if (= := V2391) (let V2392 (shen.lazyderef (tl V2390) V3021) (if (cons? V2392) (let Semantics (hd V2392) (let V2393 (shen.lazyderef (tl V2392) V3021) (if (cons? V2393) (let V2394 (shen.lazyderef (hd V2393) V3021) (if (= where V2394) (let V2395 (shen.lazyderef (tl V2393) V3021) (if (cons? V2395) (let G (hd V2395) (let V2396 (shen.lazyderef (tl V2395) V3021) (if (= () V2396) (do (shen.incinfs) (cut Throwcontrol V3021 (freeze (bind V3019 (cons where (cons (shen.lazyderef G V3021) (cons (shen.lazyderef Semantics V3021) ()))) V3021 V3022)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2389) (do (shen.bindv V2389 () V3021) (let Result (let V2397 (shen.lazyderef V3020 V3021) (if (cons? V2397) (let V2398 (shen.lazyderef (hd V2397) V3021) (if (= := V2398) (let V2399 (shen.lazyderef (tl V2397) V3021) (if (cons? V2399) (let Semantics (hd V2399) (let V2400 (shen.lazyderef (tl V2399) V3021) (if (cons? V2400) (let V2401 (shen.lazyderef (hd V2400) V3021) (if (= where V2401) (let V2402 (shen.lazyderef (tl V2400) V3021) (if (cons? V2402) (let G (hd V2402) (let V2403 (shen.lazyderef (tl V2402) V3021) (if (= () V2403) (do (shen.incinfs) (cut Throwcontrol V3021 (freeze (bind V3019 (cons where (cons (shen.lazyderef G V3021) (cons (shen.lazyderef Semantics V3021) ()))) V3021 V3022)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2389 V3021) Result))) false))) (if (= Case false) (let V2404 (shen.lazyderef V3018 V3021) (if (cons? V2404) (let X2376 (hd V2404) (let Syntax (tl V2404) (let V2405 (shen.lazyderef V3020 V3021) (if (cons? V2405) (let X (hd V2405) (let Rule (tl V2405) (do (shen.incinfs) (unify! X X2376 V3021 (freeze (shen.get-syntax+semantics Syntax V3019 Rule V3021 V3022)))))) false)))) (if (shen.pvar? V2404) (let X2376 (shen.newpv V3021) (let Syntax (shen.newpv V3021) (do (shen.bindv V2404 (cons X2376 Syntax) V3021) (let Result (let V2406 (shen.lazyderef V3020 V3021) (if (cons? V2406) (let X (hd V2406) (let Rule (tl V2406) (do (shen.incinfs) (unify! X X2376 V3021 (freeze (shen.get-syntax+semantics Syntax V3019 Rule V3021 V3022)))))) false)) (do (shen.unbindv V2404 V3021) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V3023 V3024 V3025 V3026 V3027) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2373 (shen.lazyderef V3023 V3026) (if (= () V2373) (do (shen.incinfs) (thaw V3027)) false)) (if (= Case false) (let Case (let V2374 (shen.lazyderef V3023 V3026) (if (cons? V2374) (let X (hd V2374) (let Syntax (tl V2374) (let C (shen.newpv V3026) (let X&& (shen.newpv V3026) (let B (shen.newpv V3026) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V3025 V3026 (freeze (cut Throwcontrol V3026 (freeze (bind X&& (concat && (shen.lazyderef X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V3024 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V3025) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-check Syntax V3024 V3025 V3026 V3027))))))))))))))))))))))) false)) (if (= Case false) (let V2375 (shen.lazyderef V3023 V3026) (if (cons? V2375) (let X (hd V2375) (let Syntax (tl V2375) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V3024 ()))) V3025 V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-check Syntax V3024 V3025 V3026 V3027)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3028 V3029 V3030 V3031 V3032) (let Semantics* (shen.newpv V3031) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3028 V3031))) V3031 (freeze (shen.t* (cons Semantics* (cons : (cons V3029 ()))) V3030 V3031 V3032))))))

(defun shen.rename-semantics (V3033) (cond ((cons? V3033) (cons (shen.rename-semantics (hd V3033)) (shen.rename-semantics (tl V3033)))) ((shen.grammar_symbol? V3033) (cons shen.<-sem (cons V3033 ()))) (true V3033)))



