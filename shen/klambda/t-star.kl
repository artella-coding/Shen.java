"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2831 V2832) (let Curry (shen.curry V2831) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2832)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2833) (cond ((and (cons? V2833) (shen.special? (hd V2833))) (cons (hd V2833) (map shen.curry (tl V2833)))) ((and (cons? V2833) (and (cons? (tl V2833)) (shen.extraspecial? (hd V2833)))) V2833) ((and (cons? V2833) (and (= type (hd V2833)) (and (cons? (tl V2833)) (and (cons? (tl (tl V2833))) (= () (tl (tl (tl V2833)))))))) (cons type (cons (shen.curry (hd (tl V2833))) (tl (tl V2833))))) ((and (cons? V2833) (and (cons? (tl V2833)) (cons? (tl (tl V2833))))) (shen.curry (cons (cons (hd V2833) (cons (hd (tl V2833)) ())) (tl (tl V2833))))) ((and (cons? V2833) (and (cons? (tl V2833)) (= () (tl (tl V2833))))) (cons (shen.curry (hd V2833)) (cons (shen.curry (hd (tl V2833))) ()))) (true V2833)))

(defun shen.special? (V2834) (element? V2834 (value shen.*special*)))

(defun shen.extraspecial? (V2835) (element? V2835 (value shen.*extraspecial*)))

(defun shen.t* (V2836 V2837 V2838 V2839) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2838) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2838 (freeze (bind Error (shen.errormaxinfs) V2838 V2839))))) (if (= Case false) (let Case (let V2825 (shen.lazyderef V2836 V2838) (if (= fail V2825) (do (shen.incinfs) (cut Throwcontrol V2838 (freeze (shen.prolog-failure V2838 V2839)))) false)) (if (= Case false) (let Case (let V2826 (shen.lazyderef V2836 V2838) (if (cons? V2826) (let X (hd V2826) (let V2827 (shen.lazyderef (tl V2826) V2838) (if (cons? V2827) (let V2828 (shen.lazyderef (hd V2827) V2838) (if (= : V2828) (let V2829 (shen.lazyderef (tl V2827) V2838) (if (cons? V2829) (let A (hd V2829) (let V2830 (shen.lazyderef (tl V2829) V2838) (if (= () V2830) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2838 (freeze (cut Throwcontrol V2838 (freeze (shen.th* X A V2837 V2838 V2839)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2838) (do (shen.incinfs) (shen.show V2836 V2837 V2838 (freeze (bind Datatypes (value shen.*datatypes*) V2838 (freeze (shen.udefs* V2836 V2837 Datatypes V2838 V2839))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2844) (cond ((= + V2844) (set shen.*shen-type-theory-enabled?* true)) ((= - V2844) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2853 V2854) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2855 V2856 V2857 V2858 V2859) (let Case (let V2821 (shen.lazyderef V2857 V2858) (if (cons? V2821) (let D (hd V2821) (do (shen.incinfs) (call (cons D (cons V2855 (cons V2856 ()))) V2858 V2859))) false)) (if (= Case false) (let V2822 (shen.lazyderef V2857 V2858) (if (cons? V2822) (let Ds (tl V2822) (do (shen.incinfs) (shen.udefs* V2855 V2856 Ds V2858 V2859))) false)) Case)))

(defun shen.th* (V2860 V2861 V2862 V2863 V2864) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2860 (cons : (cons V2861 ()))) V2862 V2863 (freeze (fwhen false V2863 V2864)))) (if (= Case false) (let Case (let F (shen.newpv V2863) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2860 V2863)) V2863 (freeze (bind F (shen.sigf (shen.lazyderef V2860 V2863)) V2863 (freeze (call (cons F (cons V2861 ())) V2863 V2864))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2860 V2861 V2863 V2864)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2860 V2861 V2862 V2863 V2864)) (if (= Case false) (let Case (let V2706 (shen.lazyderef V2860 V2863) (if (cons? V2706) (let F (hd V2706) (let V2707 (shen.lazyderef (tl V2706) V2863) (if (= () V2707) (do (shen.incinfs) (shen.th* F (cons --> (cons V2861 ())) V2862 V2863 V2864)) false))) false)) (if (= Case false) (let Case (let V2708 (shen.lazyderef V2860 V2863) (if (cons? V2708) (let F (hd V2708) (let V2709 (shen.lazyderef (tl V2708) V2863) (if (cons? V2709) (let X (hd V2709) (let V2710 (shen.lazyderef (tl V2709) V2863) (if (= () V2710) (let B (shen.newpv V2863) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2861 ()))) V2862 V2863 (freeze (shen.th* X B V2862 V2863 V2864))))) false))) false))) false)) (if (= Case false) (let Case (let V2711 (shen.lazyderef V2860 V2863) (if (cons? V2711) (let V2712 (shen.lazyderef (hd V2711) V2863) (if (= cons V2712) (let V2713 (shen.lazyderef (tl V2711) V2863) (if (cons? V2713) (let X (hd V2713) (let V2714 (shen.lazyderef (tl V2713) V2863) (if (cons? V2714) (let Y (hd V2714) (let V2715 (shen.lazyderef (tl V2714) V2863) (if (= () V2715) (let V2716 (shen.lazyderef V2861 V2863) (if (cons? V2716) (let V2717 (shen.lazyderef (hd V2716) V2863) (if (= list V2717) (let V2718 (shen.lazyderef (tl V2716) V2863) (if (cons? V2718) (let A (hd V2718) (let V2719 (shen.lazyderef (tl V2718) V2863) (if (= () V2719) (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons list (cons A ())) V2862 V2863 V2864)))) (if (shen.pvar? V2719) (do (shen.bindv V2719 () V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons list (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2719 V2863) Result))) false)))) (if (shen.pvar? V2718) (let A (shen.newpv V2863) (do (shen.bindv V2718 (cons A ()) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons list (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2718 V2863) Result)))) false))) (if (shen.pvar? V2717) (do (shen.bindv V2717 list V2863) (let Result (let V2720 (shen.lazyderef (tl V2716) V2863) (if (cons? V2720) (let A (hd V2720) (let V2721 (shen.lazyderef (tl V2720) V2863) (if (= () V2721) (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons list (cons A ())) V2862 V2863 V2864)))) (if (shen.pvar? V2721) (do (shen.bindv V2721 () V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons list (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2721 V2863) Result))) false)))) (if (shen.pvar? V2720) (let A (shen.newpv V2863) (do (shen.bindv V2720 (cons A ()) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons list (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2720 V2863) Result)))) false))) (do (shen.unbindv V2717 V2863) Result))) false))) (if (shen.pvar? V2716) (let A (shen.newpv V2863) (do (shen.bindv V2716 (cons list (cons A ())) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons list (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2716 V2863) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2722 (shen.lazyderef V2860 V2863) (if (cons? V2722) (let V2723 (shen.lazyderef (hd V2722) V2863) (if (= @p V2723) (let V2724 (shen.lazyderef (tl V2722) V2863) (if (cons? V2724) (let X (hd V2724) (let V2725 (shen.lazyderef (tl V2724) V2863) (if (cons? V2725) (let Y (hd V2725) (let V2726 (shen.lazyderef (tl V2725) V2863) (if (= () V2726) (let V2727 (shen.lazyderef V2861 V2863) (if (cons? V2727) (let A (hd V2727) (let V2728 (shen.lazyderef (tl V2727) V2863) (if (cons? V2728) (let V2729 (shen.lazyderef (hd V2728) V2863) (if (= * V2729) (let V2730 (shen.lazyderef (tl V2728) V2863) (if (cons? V2730) (let B (hd V2730) (let V2731 (shen.lazyderef (tl V2730) V2863) (if (= () V2731) (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y B V2862 V2863 V2864)))) (if (shen.pvar? V2731) (do (shen.bindv V2731 () V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y B V2862 V2863 V2864)))) (do (shen.unbindv V2731 V2863) Result))) false)))) (if (shen.pvar? V2730) (let B (shen.newpv V2863) (do (shen.bindv V2730 (cons B ()) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y B V2862 V2863 V2864)))) (do (shen.unbindv V2730 V2863) Result)))) false))) (if (shen.pvar? V2729) (do (shen.bindv V2729 * V2863) (let Result (let V2732 (shen.lazyderef (tl V2728) V2863) (if (cons? V2732) (let B (hd V2732) (let V2733 (shen.lazyderef (tl V2732) V2863) (if (= () V2733) (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y B V2862 V2863 V2864)))) (if (shen.pvar? V2733) (do (shen.bindv V2733 () V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y B V2862 V2863 V2864)))) (do (shen.unbindv V2733 V2863) Result))) false)))) (if (shen.pvar? V2732) (let B (shen.newpv V2863) (do (shen.bindv V2732 (cons B ()) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y B V2862 V2863 V2864)))) (do (shen.unbindv V2732 V2863) Result)))) false))) (do (shen.unbindv V2729 V2863) Result))) false))) (if (shen.pvar? V2728) (let B (shen.newpv V2863) (do (shen.bindv V2728 (cons * (cons B ())) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y B V2862 V2863 V2864)))) (do (shen.unbindv V2728 V2863) Result)))) false)))) (if (shen.pvar? V2727) (let A (shen.newpv V2863) (let B (shen.newpv V2863) (do (shen.bindv V2727 (cons A (cons * (cons B ()))) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y B V2862 V2863 V2864)))) (do (shen.unbindv V2727 V2863) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2734 (shen.lazyderef V2860 V2863) (if (cons? V2734) (let V2735 (shen.lazyderef (hd V2734) V2863) (if (= @v V2735) (let V2736 (shen.lazyderef (tl V2734) V2863) (if (cons? V2736) (let X (hd V2736) (let V2737 (shen.lazyderef (tl V2736) V2863) (if (cons? V2737) (let Y (hd V2737) (let V2738 (shen.lazyderef (tl V2737) V2863) (if (= () V2738) (let V2739 (shen.lazyderef V2861 V2863) (if (cons? V2739) (let V2740 (shen.lazyderef (hd V2739) V2863) (if (= vector V2740) (let V2741 (shen.lazyderef (tl V2739) V2863) (if (cons? V2741) (let A (hd V2741) (let V2742 (shen.lazyderef (tl V2741) V2863) (if (= () V2742) (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons vector (cons A ())) V2862 V2863 V2864)))) (if (shen.pvar? V2742) (do (shen.bindv V2742 () V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons vector (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2742 V2863) Result))) false)))) (if (shen.pvar? V2741) (let A (shen.newpv V2863) (do (shen.bindv V2741 (cons A ()) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons vector (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2741 V2863) Result)))) false))) (if (shen.pvar? V2740) (do (shen.bindv V2740 vector V2863) (let Result (let V2743 (shen.lazyderef (tl V2739) V2863) (if (cons? V2743) (let A (hd V2743) (let V2744 (shen.lazyderef (tl V2743) V2863) (if (= () V2744) (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons vector (cons A ())) V2862 V2863 V2864)))) (if (shen.pvar? V2744) (do (shen.bindv V2744 () V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons vector (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2744 V2863) Result))) false)))) (if (shen.pvar? V2743) (let A (shen.newpv V2863) (do (shen.bindv V2743 (cons A ()) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons vector (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2743 V2863) Result)))) false))) (do (shen.unbindv V2740 V2863) Result))) false))) (if (shen.pvar? V2739) (let A (shen.newpv V2863) (do (shen.bindv V2739 (cons vector (cons A ())) V2863) (let Result (do (shen.incinfs) (shen.th* X A V2862 V2863 (freeze (shen.th* Y (cons vector (cons A ())) V2862 V2863 V2864)))) (do (shen.unbindv V2739 V2863) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2745 (shen.lazyderef V2860 V2863) (if (cons? V2745) (let V2746 (shen.lazyderef (hd V2745) V2863) (if (= @s V2746) (let V2747 (shen.lazyderef (tl V2745) V2863) (if (cons? V2747) (let X (hd V2747) (let V2748 (shen.lazyderef (tl V2747) V2863) (if (cons? V2748) (let Y (hd V2748) (let V2749 (shen.lazyderef (tl V2748) V2863) (if (= () V2749) (let V2750 (shen.lazyderef V2861 V2863) (if (= string V2750) (do (shen.incinfs) (shen.th* X string V2862 V2863 (freeze (shen.th* Y string V2862 V2863 V2864)))) (if (shen.pvar? V2750) (do (shen.bindv V2750 string V2863) (let Result (do (shen.incinfs) (shen.th* X string V2862 V2863 (freeze (shen.th* Y string V2862 V2863 V2864)))) (do (shen.unbindv V2750 V2863) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2751 (shen.lazyderef V2860 V2863) (if (cons? V2751) (let V2752 (shen.lazyderef (hd V2751) V2863) (if (= lambda V2752) (let V2753 (shen.lazyderef (tl V2751) V2863) (if (cons? V2753) (let X (hd V2753) (let V2754 (shen.lazyderef (tl V2753) V2863) (if (cons? V2754) (let Y (hd V2754) (let V2755 (shen.lazyderef (tl V2754) V2863) (if (= () V2755) (let V2756 (shen.lazyderef V2861 V2863) (if (cons? V2756) (let A (hd V2756) (let V2757 (shen.lazyderef (tl V2756) V2863) (if (cons? V2757) (let V2758 (shen.lazyderef (hd V2757) V2863) (if (= --> V2758) (let V2759 (shen.lazyderef (tl V2757) V2863) (if (cons? V2759) (let B (hd V2759) (let V2760 (shen.lazyderef (tl V2759) V2863) (if (= () V2760) (let Z (shen.newpv V2863) (let X&& (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Y V2863)) V2863 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2862) V2863 V2864)))))))))) (if (shen.pvar? V2760) (do (shen.bindv V2760 () V2863) (let Result (let Z (shen.newpv V2863) (let X&& (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Y V2863)) V2863 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2862) V2863 V2864)))))))))) (do (shen.unbindv V2760 V2863) Result))) false)))) (if (shen.pvar? V2759) (let B (shen.newpv V2863) (do (shen.bindv V2759 (cons B ()) V2863) (let Result (let Z (shen.newpv V2863) (let X&& (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Y V2863)) V2863 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2862) V2863 V2864)))))))))) (do (shen.unbindv V2759 V2863) Result)))) false))) (if (shen.pvar? V2758) (do (shen.bindv V2758 --> V2863) (let Result (let V2761 (shen.lazyderef (tl V2757) V2863) (if (cons? V2761) (let B (hd V2761) (let V2762 (shen.lazyderef (tl V2761) V2863) (if (= () V2762) (let Z (shen.newpv V2863) (let X&& (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Y V2863)) V2863 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2862) V2863 V2864)))))))))) (if (shen.pvar? V2762) (do (shen.bindv V2762 () V2863) (let Result (let Z (shen.newpv V2863) (let X&& (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Y V2863)) V2863 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2862) V2863 V2864)))))))))) (do (shen.unbindv V2762 V2863) Result))) false)))) (if (shen.pvar? V2761) (let B (shen.newpv V2863) (do (shen.bindv V2761 (cons B ()) V2863) (let Result (let Z (shen.newpv V2863) (let X&& (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Y V2863)) V2863 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2862) V2863 V2864)))))))))) (do (shen.unbindv V2761 V2863) Result)))) false))) (do (shen.unbindv V2758 V2863) Result))) false))) (if (shen.pvar? V2757) (let B (shen.newpv V2863) (do (shen.bindv V2757 (cons --> (cons B ())) V2863) (let Result (let Z (shen.newpv V2863) (let X&& (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Y V2863)) V2863 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2862) V2863 V2864)))))))))) (do (shen.unbindv V2757 V2863) Result)))) false)))) (if (shen.pvar? V2756) (let A (shen.newpv V2863) (let B (shen.newpv V2863) (do (shen.bindv V2756 (cons A (cons --> (cons B ()))) V2863) (let Result (let Z (shen.newpv V2863) (let X&& (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Y V2863)) V2863 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2862) V2863 V2864)))))))))) (do (shen.unbindv V2756 V2863) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2763 (shen.lazyderef V2860 V2863) (if (cons? V2763) (let V2764 (shen.lazyderef (hd V2763) V2863) (if (= let V2764) (let V2765 (shen.lazyderef (tl V2763) V2863) (if (cons? V2765) (let X (hd V2765) (let V2766 (shen.lazyderef (tl V2765) V2863) (if (cons? V2766) (let Y (hd V2766) (let V2767 (shen.lazyderef (tl V2766) V2863) (if (cons? V2767) (let Z (hd V2767) (let V2768 (shen.lazyderef (tl V2767) V2863) (if (= () V2768) (let W (shen.newpv V2863) (let X&& (shen.newpv V2863) (let B (shen.newpv V2863) (do (shen.incinfs) (shen.th* Y B V2862 V2863 (freeze (bind X&& (shen.placeholder) V2863 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2863) (shen.lazyderef X V2863) (shen.lazyderef Z V2863)) V2863 (freeze (shen.th* W V2861 (cons (cons X&& (cons : (cons B ()))) V2862) V2863 V2864))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2769 (shen.lazyderef V2860 V2863) (if (cons? V2769) (let V2770 (shen.lazyderef (hd V2769) V2863) (if (= open V2770) (let V2771 (shen.lazyderef (tl V2769) V2863) (if (cons? V2771) (let FileName (hd V2771) (let V2772 (shen.lazyderef (tl V2771) V2863) (if (cons? V2772) (let Direction2702 (hd V2772) (let V2773 (shen.lazyderef (tl V2772) V2863) (if (= () V2773) (let V2774 (shen.lazyderef V2861 V2863) (if (cons? V2774) (let V2775 (shen.lazyderef (hd V2774) V2863) (if (= stream V2775) (let V2776 (shen.lazyderef (tl V2774) V2863) (if (cons? V2776) (let Direction (hd V2776) (let V2777 (shen.lazyderef (tl V2776) V2863) (if (= () V2777) (do (shen.incinfs) (unify! Direction Direction2702 V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* FileName string V2862 V2863 V2864)))))) (if (shen.pvar? V2777) (do (shen.bindv V2777 () V2863) (let Result (do (shen.incinfs) (unify! Direction Direction2702 V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* FileName string V2862 V2863 V2864)))))) (do (shen.unbindv V2777 V2863) Result))) false)))) (if (shen.pvar? V2776) (let Direction (shen.newpv V2863) (do (shen.bindv V2776 (cons Direction ()) V2863) (let Result (do (shen.incinfs) (unify! Direction Direction2702 V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* FileName string V2862 V2863 V2864)))))) (do (shen.unbindv V2776 V2863) Result)))) false))) (if (shen.pvar? V2775) (do (shen.bindv V2775 stream V2863) (let Result (let V2778 (shen.lazyderef (tl V2774) V2863) (if (cons? V2778) (let Direction (hd V2778) (let V2779 (shen.lazyderef (tl V2778) V2863) (if (= () V2779) (do (shen.incinfs) (unify! Direction Direction2702 V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* FileName string V2862 V2863 V2864)))))) (if (shen.pvar? V2779) (do (shen.bindv V2779 () V2863) (let Result (do (shen.incinfs) (unify! Direction Direction2702 V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* FileName string V2862 V2863 V2864)))))) (do (shen.unbindv V2779 V2863) Result))) false)))) (if (shen.pvar? V2778) (let Direction (shen.newpv V2863) (do (shen.bindv V2778 (cons Direction ()) V2863) (let Result (do (shen.incinfs) (unify! Direction Direction2702 V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* FileName string V2862 V2863 V2864)))))) (do (shen.unbindv V2778 V2863) Result)))) false))) (do (shen.unbindv V2775 V2863) Result))) false))) (if (shen.pvar? V2774) (let Direction (shen.newpv V2863) (do (shen.bindv V2774 (cons stream (cons Direction ())) V2863) (let Result (do (shen.incinfs) (unify! Direction Direction2702 V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* FileName string V2862 V2863 V2864)))))) (do (shen.unbindv V2774 V2863) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2780 (shen.lazyderef V2860 V2863) (if (cons? V2780) (let V2781 (shen.lazyderef (hd V2780) V2863) (if (= type V2781) (let V2782 (shen.lazyderef (tl V2780) V2863) (if (cons? V2782) (let X (hd V2782) (let V2783 (shen.lazyderef (tl V2782) V2863) (if (cons? V2783) (let A (hd V2783) (let V2784 (shen.lazyderef (tl V2783) V2863) (if (= () V2784) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (unify A V2861 V2863 (freeze (shen.th* X A V2862 V2863 V2864)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2785 (shen.lazyderef V2860 V2863) (if (cons? V2785) (let V2786 (shen.lazyderef (hd V2785) V2863) (if (= input+ V2786) (let V2787 (shen.lazyderef (tl V2785) V2863) (if (cons? V2787) (let A (hd V2787) (let V2788 (shen.lazyderef (tl V2787) V2863) (if (cons? V2788) (let Stream (hd V2788) (let V2789 (shen.lazyderef (tl V2788) V2863) (if (= () V2789) (let C (shen.newpv V2863) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2863)) V2863 (freeze (unify V2861 C V2863 (freeze (shen.th* Stream (cons stream (cons in ())) V2862 V2863 V2864))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2790 (shen.lazyderef V2860 V2863) (if (cons? V2790) (let V2791 (shen.lazyderef (hd V2790) V2863) (if (= set V2791) (let V2792 (shen.lazyderef (tl V2790) V2863) (if (cons? V2792) (let Var (hd V2792) (let V2793 (shen.lazyderef (tl V2792) V2863) (if (cons? V2793) (let Val (hd V2793) (let V2794 (shen.lazyderef (tl V2793) V2863) (if (= () V2794) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (shen.th* Var symbol V2862 V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* (cons value (cons Var ())) V2861 V2862 V2863 (freeze (shen.th* Val V2861 V2862 V2863 V2864)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2795 (shen.lazyderef V2860 V2863) (if (cons? V2795) (let V2796 (shen.lazyderef (hd V2795) V2863) (if (= shen.<-sem V2796) (let V2797 (shen.lazyderef (tl V2795) V2863) (if (cons? V2797) (let F (hd V2797) (let V2798 (shen.lazyderef (tl V2797) V2863) (if (= () V2798) (let A (shen.newpv V2863) (let F&& (shen.newpv V2863) (let B (shen.newpv V2863) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2862 V2863 (freeze (cut Throwcontrol V2863 (freeze (bind F&& (concat && (shen.lazyderef F V2863)) V2863 (freeze (cut Throwcontrol V2863 (freeze (shen.th* F&& V2861 (cons (cons F&& (cons : (cons B ()))) V2862) V2863 V2864))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2799 (shen.lazyderef V2860 V2863) (if (cons? V2799) (let V2800 (shen.lazyderef (hd V2799) V2863) (if (= fail V2800) (let V2801 (shen.lazyderef (tl V2799) V2863) (if (= () V2801) (let V2802 (shen.lazyderef V2861 V2863) (if (= symbol V2802) (do (shen.incinfs) (thaw V2864)) (if (shen.pvar? V2802) (do (shen.bindv V2802 symbol V2863) (let Result (do (shen.incinfs) (thaw V2864)) (do (shen.unbindv V2802 V2863) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2863) (do (shen.incinfs) (shen.t*-hyps V2862 NewHyp V2863 (freeze (shen.th* V2860 V2861 NewHyp V2863 V2864))))) (if (= Case false) (let Case (let V2803 (shen.lazyderef V2860 V2863) (if (cons? V2803) (let V2804 (shen.lazyderef (hd V2803) V2863) (if (= define V2804) (let V2805 (shen.lazyderef (tl V2803) V2863) (if (cons? V2805) (let F (hd V2805) (let X (tl V2805) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (shen.t*-def (cons define (cons F X)) V2861 V2862 V2863 V2864)))))) false)) false)) false)) (if (= Case false) (let Case (let V2806 (shen.lazyderef V2860 V2863) (if (cons? V2806) (let V2807 (shen.lazyderef (hd V2806) V2863) (if (= defcc V2807) (let V2808 (shen.lazyderef (tl V2806) V2863) (if (cons? V2808) (let F (hd V2808) (let X (tl V2808) (do (shen.incinfs) (cut Throwcontrol V2863 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2861 V2862 V2863 V2864)))))) false)) false)) false)) (if (= Case false) (let Case (let V2809 (shen.lazyderef V2860 V2863) (if (cons? V2809) (let V2810 (shen.lazyderef (hd V2809) V2863) (if (= defmacro V2810) (let V2811 (shen.lazyderef V2861 V2863) (if (= unit V2811) (do (shen.incinfs) (cut Throwcontrol V2863 V2864)) (if (shen.pvar? V2811) (do (shen.bindv V2811 unit V2863) (let Result (do (shen.incinfs) (cut Throwcontrol V2863 V2864)) (do (shen.unbindv V2811 V2863) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2812 (shen.lazyderef V2860 V2863) (if (cons? V2812) (let V2813 (shen.lazyderef (hd V2812) V2863) (if (= shen.process-datatype V2813) (let V2814 (shen.lazyderef V2861 V2863) (if (= symbol V2814) (do (shen.incinfs) (thaw V2864)) (if (shen.pvar? V2814) (do (shen.bindv V2814 symbol V2863) (let Result (do (shen.incinfs) (thaw V2864)) (do (shen.unbindv V2814 V2863) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2815 (shen.lazyderef V2860 V2863) (if (cons? V2815) (let V2816 (shen.lazyderef (hd V2815) V2863) (if (= shen.synonyms-help V2816) (let V2817 (shen.lazyderef V2861 V2863) (if (= symbol V2817) (do (shen.incinfs) (thaw V2864)) (if (shen.pvar? V2817) (do (shen.bindv V2817 symbol V2863) (let Result (do (shen.incinfs) (thaw V2864)) (do (shen.unbindv V2817 V2863) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2863) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2863 (freeze (shen.udefs* (cons V2860 (cons : (cons V2861 ()))) V2862 Datatypes V2863 V2864))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2865 V2866 V2867 V2868) (let Case (let V2617 (shen.lazyderef V2865 V2867) (if (cons? V2617) (let V2618 (shen.lazyderef (hd V2617) V2867) (if (cons? V2618) (let V2619 (shen.lazyderef (hd V2618) V2867) (if (cons? V2619) (let V2620 (shen.lazyderef (hd V2619) V2867) (if (= cons V2620) (let V2621 (shen.lazyderef (tl V2619) V2867) (if (cons? V2621) (let X (hd V2621) (let V2622 (shen.lazyderef (tl V2621) V2867) (if (cons? V2622) (let Y (hd V2622) (let V2623 (shen.lazyderef (tl V2622) V2867) (if (= () V2623) (let V2624 (shen.lazyderef (tl V2618) V2867) (if (cons? V2624) (let V2625 (shen.lazyderef (hd V2624) V2867) (if (= : V2625) (let V2626 (shen.lazyderef (tl V2624) V2867) (if (cons? V2626) (let V2627 (shen.lazyderef (hd V2626) V2867) (if (cons? V2627) (let V2628 (shen.lazyderef (hd V2627) V2867) (if (= list V2628) (let V2629 (shen.lazyderef (tl V2627) V2867) (if (cons? V2629) (let A (hd V2629) (let V2630 (shen.lazyderef (tl V2629) V2867) (if (= () V2630) (let V2631 (shen.lazyderef (tl V2626) V2867) (if (= () V2631) (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2631) (do (shen.bindv V2631 () V2867) (let Result (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2631 V2867) Result))) false))) (if (shen.pvar? V2630) (do (shen.bindv V2630 () V2867) (let Result (let V2632 (shen.lazyderef (tl V2626) V2867) (if (= () V2632) (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2632) (do (shen.bindv V2632 () V2867) (let Result (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2632 V2867) Result))) false))) (do (shen.unbindv V2630 V2867) Result))) false)))) (if (shen.pvar? V2629) (let A (shen.newpv V2867) (do (shen.bindv V2629 (cons A ()) V2867) (let Result (let V2633 (shen.lazyderef (tl V2626) V2867) (if (= () V2633) (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2633) (do (shen.bindv V2633 () V2867) (let Result (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2633 V2867) Result))) false))) (do (shen.unbindv V2629 V2867) Result)))) false))) (if (shen.pvar? V2628) (do (shen.bindv V2628 list V2867) (let Result (let V2634 (shen.lazyderef (tl V2627) V2867) (if (cons? V2634) (let A (hd V2634) (let V2635 (shen.lazyderef (tl V2634) V2867) (if (= () V2635) (let V2636 (shen.lazyderef (tl V2626) V2867) (if (= () V2636) (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2636) (do (shen.bindv V2636 () V2867) (let Result (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2636 V2867) Result))) false))) (if (shen.pvar? V2635) (do (shen.bindv V2635 () V2867) (let Result (let V2637 (shen.lazyderef (tl V2626) V2867) (if (= () V2637) (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2637) (do (shen.bindv V2637 () V2867) (let Result (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2637 V2867) Result))) false))) (do (shen.unbindv V2635 V2867) Result))) false)))) (if (shen.pvar? V2634) (let A (shen.newpv V2867) (do (shen.bindv V2634 (cons A ()) V2867) (let Result (let V2638 (shen.lazyderef (tl V2626) V2867) (if (= () V2638) (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2638) (do (shen.bindv V2638 () V2867) (let Result (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2638 V2867) Result))) false))) (do (shen.unbindv V2634 V2867) Result)))) false))) (do (shen.unbindv V2628 V2867) Result))) false))) (if (shen.pvar? V2627) (let A (shen.newpv V2867) (do (shen.bindv V2627 (cons list (cons A ())) V2867) (let Result (let V2639 (shen.lazyderef (tl V2626) V2867) (if (= () V2639) (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2639) (do (shen.bindv V2639 () V2867) (let Result (let Hyp (tl V2617) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons list (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2639 V2867) Result))) false))) (do (shen.unbindv V2627 V2867) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2640 (shen.lazyderef V2865 V2867) (if (cons? V2640) (let V2641 (shen.lazyderef (hd V2640) V2867) (if (cons? V2641) (let V2642 (shen.lazyderef (hd V2641) V2867) (if (cons? V2642) (let V2643 (shen.lazyderef (hd V2642) V2867) (if (= @p V2643) (let V2644 (shen.lazyderef (tl V2642) V2867) (if (cons? V2644) (let X (hd V2644) (let V2645 (shen.lazyderef (tl V2644) V2867) (if (cons? V2645) (let Y (hd V2645) (let V2646 (shen.lazyderef (tl V2645) V2867) (if (= () V2646) (let V2647 (shen.lazyderef (tl V2641) V2867) (if (cons? V2647) (let V2648 (shen.lazyderef (hd V2647) V2867) (if (= : V2648) (let V2649 (shen.lazyderef (tl V2647) V2867) (if (cons? V2649) (let V2650 (shen.lazyderef (hd V2649) V2867) (if (cons? V2650) (let A (hd V2650) (let V2651 (shen.lazyderef (tl V2650) V2867) (if (cons? V2651) (let V2652 (shen.lazyderef (hd V2651) V2867) (if (= * V2652) (let V2653 (shen.lazyderef (tl V2651) V2867) (if (cons? V2653) (let B (hd V2653) (let V2654 (shen.lazyderef (tl V2653) V2867) (if (= () V2654) (let V2655 (shen.lazyderef (tl V2649) V2867) (if (= () V2655) (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2655) (do (shen.bindv V2655 () V2867) (let Result (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2655 V2867) Result))) false))) (if (shen.pvar? V2654) (do (shen.bindv V2654 () V2867) (let Result (let V2656 (shen.lazyderef (tl V2649) V2867) (if (= () V2656) (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2656) (do (shen.bindv V2656 () V2867) (let Result (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2656 V2867) Result))) false))) (do (shen.unbindv V2654 V2867) Result))) false)))) (if (shen.pvar? V2653) (let B (shen.newpv V2867) (do (shen.bindv V2653 (cons B ()) V2867) (let Result (let V2657 (shen.lazyderef (tl V2649) V2867) (if (= () V2657) (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2657) (do (shen.bindv V2657 () V2867) (let Result (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2657 V2867) Result))) false))) (do (shen.unbindv V2653 V2867) Result)))) false))) (if (shen.pvar? V2652) (do (shen.bindv V2652 * V2867) (let Result (let V2658 (shen.lazyderef (tl V2651) V2867) (if (cons? V2658) (let B (hd V2658) (let V2659 (shen.lazyderef (tl V2658) V2867) (if (= () V2659) (let V2660 (shen.lazyderef (tl V2649) V2867) (if (= () V2660) (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2660) (do (shen.bindv V2660 () V2867) (let Result (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2660 V2867) Result))) false))) (if (shen.pvar? V2659) (do (shen.bindv V2659 () V2867) (let Result (let V2661 (shen.lazyderef (tl V2649) V2867) (if (= () V2661) (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2661) (do (shen.bindv V2661 () V2867) (let Result (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2661 V2867) Result))) false))) (do (shen.unbindv V2659 V2867) Result))) false)))) (if (shen.pvar? V2658) (let B (shen.newpv V2867) (do (shen.bindv V2658 (cons B ()) V2867) (let Result (let V2662 (shen.lazyderef (tl V2649) V2867) (if (= () V2662) (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2662) (do (shen.bindv V2662 () V2867) (let Result (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2662 V2867) Result))) false))) (do (shen.unbindv V2658 V2867) Result)))) false))) (do (shen.unbindv V2652 V2867) Result))) false))) (if (shen.pvar? V2651) (let B (shen.newpv V2867) (do (shen.bindv V2651 (cons * (cons B ())) V2867) (let Result (let V2663 (shen.lazyderef (tl V2649) V2867) (if (= () V2663) (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2663) (do (shen.bindv V2663 () V2867) (let Result (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2663 V2867) Result))) false))) (do (shen.unbindv V2651 V2867) Result)))) false)))) (if (shen.pvar? V2650) (let A (shen.newpv V2867) (let B (shen.newpv V2867) (do (shen.bindv V2650 (cons A (cons * (cons B ()))) V2867) (let Result (let V2664 (shen.lazyderef (tl V2649) V2867) (if (= () V2664) (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2664) (do (shen.bindv V2664 () V2867) (let Result (let Hyp (tl V2640) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (shen.lazyderef B V2867) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2664 V2867) Result))) false))) (do (shen.unbindv V2650 V2867) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2665 (shen.lazyderef V2865 V2867) (if (cons? V2665) (let V2666 (shen.lazyderef (hd V2665) V2867) (if (cons? V2666) (let V2667 (shen.lazyderef (hd V2666) V2867) (if (cons? V2667) (let V2668 (shen.lazyderef (hd V2667) V2867) (if (= @v V2668) (let V2669 (shen.lazyderef (tl V2667) V2867) (if (cons? V2669) (let X (hd V2669) (let V2670 (shen.lazyderef (tl V2669) V2867) (if (cons? V2670) (let Y (hd V2670) (let V2671 (shen.lazyderef (tl V2670) V2867) (if (= () V2671) (let V2672 (shen.lazyderef (tl V2666) V2867) (if (cons? V2672) (let V2673 (shen.lazyderef (hd V2672) V2867) (if (= : V2673) (let V2674 (shen.lazyderef (tl V2672) V2867) (if (cons? V2674) (let V2675 (shen.lazyderef (hd V2674) V2867) (if (cons? V2675) (let V2676 (shen.lazyderef (hd V2675) V2867) (if (= vector V2676) (let V2677 (shen.lazyderef (tl V2675) V2867) (if (cons? V2677) (let A (hd V2677) (let V2678 (shen.lazyderef (tl V2677) V2867) (if (= () V2678) (let V2679 (shen.lazyderef (tl V2674) V2867) (if (= () V2679) (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2679) (do (shen.bindv V2679 () V2867) (let Result (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2679 V2867) Result))) false))) (if (shen.pvar? V2678) (do (shen.bindv V2678 () V2867) (let Result (let V2680 (shen.lazyderef (tl V2674) V2867) (if (= () V2680) (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2680) (do (shen.bindv V2680 () V2867) (let Result (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2680 V2867) Result))) false))) (do (shen.unbindv V2678 V2867) Result))) false)))) (if (shen.pvar? V2677) (let A (shen.newpv V2867) (do (shen.bindv V2677 (cons A ()) V2867) (let Result (let V2681 (shen.lazyderef (tl V2674) V2867) (if (= () V2681) (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2681) (do (shen.bindv V2681 () V2867) (let Result (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2681 V2867) Result))) false))) (do (shen.unbindv V2677 V2867) Result)))) false))) (if (shen.pvar? V2676) (do (shen.bindv V2676 vector V2867) (let Result (let V2682 (shen.lazyderef (tl V2675) V2867) (if (cons? V2682) (let A (hd V2682) (let V2683 (shen.lazyderef (tl V2682) V2867) (if (= () V2683) (let V2684 (shen.lazyderef (tl V2674) V2867) (if (= () V2684) (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2684) (do (shen.bindv V2684 () V2867) (let Result (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2684 V2867) Result))) false))) (if (shen.pvar? V2683) (do (shen.bindv V2683 () V2867) (let Result (let V2685 (shen.lazyderef (tl V2674) V2867) (if (= () V2685) (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2685) (do (shen.bindv V2685 () V2867) (let Result (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2685 V2867) Result))) false))) (do (shen.unbindv V2683 V2867) Result))) false)))) (if (shen.pvar? V2682) (let A (shen.newpv V2867) (do (shen.bindv V2682 (cons A ()) V2867) (let Result (let V2686 (shen.lazyderef (tl V2674) V2867) (if (= () V2686) (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2686) (do (shen.bindv V2686 () V2867) (let Result (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2686 V2867) Result))) false))) (do (shen.unbindv V2682 V2867) Result)))) false))) (do (shen.unbindv V2676 V2867) Result))) false))) (if (shen.pvar? V2675) (let A (shen.newpv V2867) (do (shen.bindv V2675 (cons vector (cons A ())) V2867) (let Result (let V2687 (shen.lazyderef (tl V2674) V2867) (if (= () V2687) (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2687) (do (shen.bindv V2687 () V2867) (let Result (let Hyp (tl V2665) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons (shen.lazyderef A V2867) ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons (cons vector (cons (shen.lazyderef A V2867) ())) ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2687 V2867) Result))) false))) (do (shen.unbindv V2675 V2867) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2688 (shen.lazyderef V2865 V2867) (if (cons? V2688) (let V2689 (shen.lazyderef (hd V2688) V2867) (if (cons? V2689) (let V2690 (shen.lazyderef (hd V2689) V2867) (if (cons? V2690) (let V2691 (shen.lazyderef (hd V2690) V2867) (if (= @s V2691) (let V2692 (shen.lazyderef (tl V2690) V2867) (if (cons? V2692) (let X (hd V2692) (let V2693 (shen.lazyderef (tl V2692) V2867) (if (cons? V2693) (let Y (hd V2693) (let V2694 (shen.lazyderef (tl V2693) V2867) (if (= () V2694) (let V2695 (shen.lazyderef (tl V2689) V2867) (if (cons? V2695) (let V2696 (shen.lazyderef (hd V2695) V2867) (if (= : V2696) (let V2697 (shen.lazyderef (tl V2695) V2867) (if (cons? V2697) (let V2698 (shen.lazyderef (hd V2697) V2867) (if (= string V2698) (let V2699 (shen.lazyderef (tl V2697) V2867) (if (= () V2699) (let Hyp (tl V2688) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons string ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2699) (do (shen.bindv V2699 () V2867) (let Result (let Hyp (tl V2688) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons string ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2699 V2867) Result))) false))) (if (shen.pvar? V2698) (do (shen.bindv V2698 string V2867) (let Result (let V2700 (shen.lazyderef (tl V2697) V2867) (if (= () V2700) (let Hyp (tl V2688) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons string ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (if (shen.pvar? V2700) (do (shen.bindv V2700 () V2867) (let Result (let Hyp (tl V2688) (do (shen.incinfs) (bind V2866 (cons (cons (shen.lazyderef X V2867) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2867) (cons : (cons string ()))) (shen.lazyderef Hyp V2867))) V2867 V2868))) (do (shen.unbindv V2700 V2867) Result))) false))) (do (shen.unbindv V2698 V2867) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2701 (shen.lazyderef V2865 V2867) (if (cons? V2701) (let X (hd V2701) (let Hyp (tl V2701) (let NewHyps (shen.newpv V2867) (do (shen.incinfs) (bind V2866 (cons (shen.lazyderef X V2867) (shen.lazyderef NewHyps V2867)) V2867 (freeze (shen.t*-hyps Hyp NewHyps V2867 V2868))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2881 V2882 V2883 V2884) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2881 V2883)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2882 V2883) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2884))))))))) (true (thaw V2884))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2885) (cond ((and (cons? V2885) (and (cons? (tl V2885)) (and (= : (hd (tl V2885))) (and (cons? (tl (tl V2885))) (= () (tl (tl (tl V2885)))))))) (shen.prhush (shen.app (hd V2885) (cn " : " (shen.app (hd (tl (tl V2885))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2885 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2888 V2889) (cond ((= () V2888) shen.skip) ((cons? V2888) (do (shen.prhush (shen.app V2889 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2888)) (do (nl 1) (shen.show-assumptions (tl V2888) (+ V2889 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2890) (cons? (assoc V2890 (value shen.*signedfuncs*))))

(defun shen.sigf (V2891) (concat shen.type-signature-of- V2891))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2892 V2893 V2894 V2895) (let Case (let V2604 (shen.lazyderef V2893 V2894) (if (= number V2604) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2892 V2894)) V2894 V2895)) (if (shen.pvar? V2604) (do (shen.bindv V2604 number V2894) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2892 V2894)) V2894 V2895)) (do (shen.unbindv V2604 V2894) Result))) false))) (if (= Case false) (let Case (let V2605 (shen.lazyderef V2893 V2894) (if (= boolean V2605) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2892 V2894)) V2894 V2895)) (if (shen.pvar? V2605) (do (shen.bindv V2605 boolean V2894) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2892 V2894)) V2894 V2895)) (do (shen.unbindv V2605 V2894) Result))) false))) (if (= Case false) (let Case (let V2606 (shen.lazyderef V2893 V2894) (if (= string V2606) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2892 V2894)) V2894 V2895)) (if (shen.pvar? V2606) (do (shen.bindv V2606 string V2894) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2892 V2894)) V2894 V2895)) (do (shen.unbindv V2606 V2894) Result))) false))) (if (= Case false) (let Case (let V2607 (shen.lazyderef V2893 V2894) (if (= symbol V2607) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2892 V2894)) V2894 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2892 V2894))) V2894 V2895)))) (if (shen.pvar? V2607) (do (shen.bindv V2607 symbol V2894) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2892 V2894)) V2894 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2892 V2894))) V2894 V2895)))) (do (shen.unbindv V2607 V2894) Result))) false))) (if (= Case false) (let V2608 (shen.lazyderef V2892 V2894) (if (= () V2608) (let V2609 (shen.lazyderef V2893 V2894) (if (cons? V2609) (let V2610 (shen.lazyderef (hd V2609) V2894) (if (= list V2610) (let V2611 (shen.lazyderef (tl V2609) V2894) (if (cons? V2611) (let A (hd V2611) (let V2612 (shen.lazyderef (tl V2611) V2894) (if (= () V2612) (do (shen.incinfs) (thaw V2895)) (if (shen.pvar? V2612) (do (shen.bindv V2612 () V2894) (let Result (do (shen.incinfs) (thaw V2895)) (do (shen.unbindv V2612 V2894) Result))) false)))) (if (shen.pvar? V2611) (let A (shen.newpv V2894) (do (shen.bindv V2611 (cons A ()) V2894) (let Result (do (shen.incinfs) (thaw V2895)) (do (shen.unbindv V2611 V2894) Result)))) false))) (if (shen.pvar? V2610) (do (shen.bindv V2610 list V2894) (let Result (let V2613 (shen.lazyderef (tl V2609) V2894) (if (cons? V2613) (let A (hd V2613) (let V2614 (shen.lazyderef (tl V2613) V2894) (if (= () V2614) (do (shen.incinfs) (thaw V2895)) (if (shen.pvar? V2614) (do (shen.bindv V2614 () V2894) (let Result (do (shen.incinfs) (thaw V2895)) (do (shen.unbindv V2614 V2894) Result))) false)))) (if (shen.pvar? V2613) (let A (shen.newpv V2894) (do (shen.bindv V2613 (cons A ()) V2894) (let Result (do (shen.incinfs) (thaw V2895)) (do (shen.unbindv V2613 V2894) Result)))) false))) (do (shen.unbindv V2610 V2894) Result))) false))) (if (shen.pvar? V2609) (let A (shen.newpv V2894) (do (shen.bindv V2609 (cons list (cons A ())) V2894) (let Result (do (shen.incinfs) (thaw V2895)) (do (shen.unbindv V2609 V2894) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2896 V2897 V2898 V2899 V2900) (let Case (let V2595 (shen.lazyderef V2898 V2899) (if (cons? V2595) (let V2596 (shen.lazyderef (hd V2595) V2899) (if (cons? V2596) (let Y (hd V2596) (let V2597 (shen.lazyderef (tl V2596) V2899) (if (cons? V2597) (let V2598 (shen.lazyderef (hd V2597) V2899) (if (= : V2598) (let V2599 (shen.lazyderef (tl V2597) V2899) (if (cons? V2599) (let B (hd V2599) (let V2600 (shen.lazyderef (tl V2599) V2899) (if (= () V2600) (do (shen.incinfs) (identical V2896 Y V2899 (freeze (unify! V2897 B V2899 V2900)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2601 (shen.lazyderef V2898 V2899) (if (cons? V2601) (let Hyp (tl V2601) (do (shen.incinfs) (shen.by_hypothesis V2896 V2897 Hyp V2899 V2900))) false)) Case)))

(defun shen.t*-def (V2901 V2902 V2903 V2904 V2905) (let V2589 (shen.lazyderef V2901 V2904) (if (cons? V2589) (let V2590 (shen.lazyderef (hd V2589) V2904) (if (= define V2590) (let V2591 (shen.lazyderef (tl V2589) V2904) (if (cons? V2591) (let F (hd V2591) (let X (tl V2591) (let E (shen.newpv V2904) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2902 V2903 V2904 V2905))))) false)) false)) false)))

(defun shen.t*-defh (V2906 V2907 V2908 V2909 V2910 V2911) (let V2585 (shen.lazyderef V2906 V2910) (if (cons? V2585) (let Sig (hd V2585) (let Rules (tl V2585) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2907 V2908 V2909 Rules V2910 V2911)))) false)))

(defun shen.t*-defhh (V2912 V2913 V2914 V2915 V2916 V2917 V2918 V2919) (do (shen.incinfs) (shen.t*-rules V2917 V2913 1 V2914 (cons (cons V2914 (cons : (cons V2913 ()))) V2916) V2918 (freeze (shen.memo V2914 V2912 V2915 V2918 V2919)))))

(defun shen.memo (V2920 V2921 V2922 V2923 V2924) (let Jnk (shen.newpv V2923) (do (shen.incinfs) (unify! V2922 V2921 V2923 (freeze (bind Jnk (declare (shen.lazyderef V2920 V2923) (shen.lazyderef V2922 V2923)) V2923 V2924))))))

(defun shen.<sig+rules> (V2929) (let Result (let Parse_shen.<signature> (shen.<signature> V2929) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2930) (cond ((and (cons? V2930) (and (cons? (tl V2930)) (and (= () (tl (tl V2930))) (= (hd V2930) protect)))) V2930) ((cons? V2930) (map shen.ue V2930)) ((variable? V2930) (concat && V2930)) (true V2930)))

(defun shen.ue-sig (V2931) (cond ((cons? V2931) (map shen.ue-sig V2931)) ((variable? V2931) (concat &&& V2931)) (true V2931)))

(defun shen.ues (V2936) (cond ((shen.ue? V2936) (cons V2936 ())) ((cons? V2936) (union (shen.ues (hd V2936)) (shen.ues (tl V2936)))) (true ())))

(defun shen.ue? (V2937) (and (symbol? V2937) (shen.ue-h? (str V2937))))

(defun shen.ue-h? (V2944) (cond ((and (shen.+string? V2944) (and (= "&" (pos V2944 0)) (and (shen.+string? (tlstr V2944)) (= "&" (pos (tlstr V2944) 0))))) true) (true false)))

(defun shen.t*-rules (V2945 V2946 V2947 V2948 V2949 V2950 V2951) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2560 (shen.lazyderef V2945 V2950) (if (= () V2560) (do (shen.incinfs) (thaw V2951)) false)) (if (= Case false) (let Case (let V2561 (shen.lazyderef V2945 V2950) (if (cons? V2561) (let V2562 (shen.lazyderef (hd V2561) V2950) (if (cons? V2562) (let V2563 (shen.lazyderef (hd V2562) V2950) (if (= () V2563) (let V2564 (shen.lazyderef (tl V2562) V2950) (if (cons? V2564) (let Action (hd V2564) (let V2565 (shen.lazyderef (tl V2564) V2950) (if (= () V2565) (let Rules (tl V2561) (let V2566 (shen.lazyderef V2946 V2950) (if (cons? V2566) (let V2567 (shen.lazyderef (hd V2566) V2950) (if (= --> V2567) (let V2568 (shen.lazyderef (tl V2566) V2950) (if (cons? V2568) (let A (hd V2568) (let V2569 (shen.lazyderef (tl V2568) V2950) (if (= () V2569) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2949 V2950 (freeze (cut Throwcontrol V2950 (freeze (shen.t*-rules Rules A (+ V2947 1) V2948 V2949 V2950 V2951)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2570 (shen.lazyderef V2945 V2950) (if (cons? V2570) (let Rule (hd V2570) (let Rules (tl V2570) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2946 V2949 V2950 (freeze (cut Throwcontrol V2950 (freeze (shen.t*-rules Rules V2946 (+ V2947 1) V2948 V2949 V2950 V2951)))))))) false)) (if (= Case false) (let Err (shen.newpv V2950) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2947 V2950) (cn " of " (shen.app (shen.lazyderef V2948 V2950) "" shen.a)) shen.a))) V2950 V2951))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2952 V2953 V2954 V2955 V2956) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2542 (shen.lazyderef V2952 V2955) (if (cons? V2542) (let V2543 (shen.lazyderef (hd V2542) V2955) (if (= () V2543) (let V2544 (shen.lazyderef (tl V2542) V2955) (if (cons? V2544) (let Action (hd V2544) (let V2545 (shen.lazyderef (tl V2544) V2955) (if (= () V2545) (do (shen.incinfs) (cut Throwcontrol V2955 (freeze (shen.t*-action (shen.curry Action) V2953 V2954 V2955 V2956)))) false))) false)) false)) false)) (if (= Case false) (let V2546 (shen.lazyderef V2952 V2955) (if (cons? V2546) (let V2547 (shen.lazyderef (hd V2546) V2955) (if (cons? V2547) (let Pattern (hd V2547) (let Patterns (tl V2547) (let V2548 (shen.lazyderef (tl V2546) V2955) (if (cons? V2548) (let Action (hd V2548) (let V2549 (shen.lazyderef (tl V2548) V2955) (if (= () V2549) (let V2550 (shen.lazyderef V2953 V2955) (if (cons? V2550) (let A (hd V2550) (let V2551 (shen.lazyderef (tl V2550) V2955) (if (cons? V2551) (let V2552 (shen.lazyderef (hd V2551) V2955) (if (= --> V2552) (let V2553 (shen.lazyderef (tl V2551) V2955) (if (cons? V2553) (let B (hd V2553) (let V2554 (shen.lazyderef (tl V2553) V2955) (if (= () V2554) (do (shen.incinfs) (shen.t*-pattern Pattern A V2955 (freeze (cut Throwcontrol V2955 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2954) V2955 V2956)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2957 V2958 V2959 V2960 V2961) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2519 (shen.lazyderef V2957 V2960) (if (cons? V2519) (let V2520 (shen.lazyderef (hd V2519) V2960) (if (= where V2520) (let V2521 (shen.lazyderef (tl V2519) V2960) (if (cons? V2521) (let P (hd V2521) (let V2522 (shen.lazyderef (tl V2521) V2960) (if (cons? V2522) (let Action (hd V2522) (let V2523 (shen.lazyderef (tl V2522) V2960) (if (= () V2523) (do (shen.incinfs) (cut Throwcontrol V2960 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2959 V2960 (freeze (cut Throwcontrol V2960 (freeze (shen.t*-action Action V2958 (cons (cons P (cons : (cons verified ()))) V2959) V2960 V2961)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2524 (shen.lazyderef V2957 V2960) (if (cons? V2524) (let V2525 (shen.lazyderef (hd V2524) V2960) (if (= shen.choicepoint! V2525) (let V2526 (shen.lazyderef (tl V2524) V2960) (if (cons? V2526) (let V2527 (shen.lazyderef (hd V2526) V2960) (if (cons? V2527) (let V2528 (shen.lazyderef (hd V2527) V2960) (if (cons? V2528) (let V2529 (shen.lazyderef (hd V2528) V2960) (if (= fail-if V2529) (let V2530 (shen.lazyderef (tl V2528) V2960) (if (cons? V2530) (let F (hd V2530) (let V2531 (shen.lazyderef (tl V2530) V2960) (if (= () V2531) (let V2532 (shen.lazyderef (tl V2527) V2960) (if (cons? V2532) (let Action (hd V2532) (let V2533 (shen.lazyderef (tl V2532) V2960) (if (= () V2533) (let V2534 (shen.lazyderef (tl V2526) V2960) (if (= () V2534) (do (shen.incinfs) (cut Throwcontrol V2960 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2958 V2959 V2960 V2961)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2535 (shen.lazyderef V2957 V2960) (if (cons? V2535) (let V2536 (shen.lazyderef (hd V2535) V2960) (if (= shen.choicepoint! V2536) (let V2537 (shen.lazyderef (tl V2535) V2960) (if (cons? V2537) (let Action (hd V2537) (let V2538 (shen.lazyderef (tl V2537) V2960) (if (= () V2538) (do (shen.incinfs) (cut Throwcontrol V2960 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2958 V2959 V2960 V2961)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2957 (cons : (cons V2958 ()))) V2959 V2960 V2961)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2962 V2963 V2964 V2965) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2964) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2962) Hyp V2964 (freeze (cut Throwcontrol V2964 (freeze (shen.t* (cons V2962 (cons : (cons V2963 ()))) Hyp V2964 V2965))))))))))

(defun shen.tms->hyp (V2966 V2967 V2968 V2969) (let Case (let V2503 (shen.lazyderef V2966 V2968) (if (= () V2503) (let V2504 (shen.lazyderef V2967 V2968) (if (= () V2504) (do (shen.incinfs) (thaw V2969)) (if (shen.pvar? V2504) (do (shen.bindv V2504 () V2968) (let Result (do (shen.incinfs) (thaw V2969)) (do (shen.unbindv V2504 V2968) Result))) false))) false)) (if (= Case false) (let V2505 (shen.lazyderef V2966 V2968) (if (cons? V2505) (let Tm2500 (hd V2505) (let Tms (tl V2505) (let V2506 (shen.lazyderef V2967 V2968) (if (cons? V2506) (let V2507 (shen.lazyderef (hd V2506) V2968) (if (cons? V2507) (let Tm (hd V2507) (let V2508 (shen.lazyderef (tl V2507) V2968) (if (cons? V2508) (let V2509 (shen.lazyderef (hd V2508) V2968) (if (= : V2509) (let V2510 (shen.lazyderef (tl V2508) V2968) (if (cons? V2510) (let A (hd V2510) (let V2511 (shen.lazyderef (tl V2510) V2968) (if (= () V2511) (let Hyp (tl V2506) (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (if (shen.pvar? V2511) (do (shen.bindv V2511 () V2968) (let Result (let Hyp (tl V2506) (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2511 V2968) Result))) false)))) (if (shen.pvar? V2510) (let A (shen.newpv V2968) (do (shen.bindv V2510 (cons A ()) V2968) (let Result (let Hyp (tl V2506) (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2510 V2968) Result)))) false))) (if (shen.pvar? V2509) (do (shen.bindv V2509 : V2968) (let Result (let V2512 (shen.lazyderef (tl V2508) V2968) (if (cons? V2512) (let A (hd V2512) (let V2513 (shen.lazyderef (tl V2512) V2968) (if (= () V2513) (let Hyp (tl V2506) (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (if (shen.pvar? V2513) (do (shen.bindv V2513 () V2968) (let Result (let Hyp (tl V2506) (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2513 V2968) Result))) false)))) (if (shen.pvar? V2512) (let A (shen.newpv V2968) (do (shen.bindv V2512 (cons A ()) V2968) (let Result (let Hyp (tl V2506) (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2512 V2968) Result)))) false))) (do (shen.unbindv V2509 V2968) Result))) false))) (if (shen.pvar? V2508) (let A (shen.newpv V2968) (do (shen.bindv V2508 (cons : (cons A ())) V2968) (let Result (let Hyp (tl V2506) (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2508 V2968) Result)))) false)))) (if (shen.pvar? V2507) (let Tm (shen.newpv V2968) (let A (shen.newpv V2968) (do (shen.bindv V2507 (cons Tm (cons : (cons A ()))) V2968) (let Result (let Hyp (tl V2506) (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2507 V2968) Result))))) false))) (if (shen.pvar? V2506) (let Tm (shen.newpv V2968) (let A (shen.newpv V2968) (let Hyp (shen.newpv V2968) (do (shen.bindv V2506 (cons (cons Tm (cons : (cons A ()))) Hyp) V2968) (let Result (do (shen.incinfs) (unify! Tm Tm2500 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969)))) (do (shen.unbindv V2506 V2968) Result)))))) false))))) false)) Case)))

(defun findall (V2970 V2971 V2972 V2973 V2974) (let B (shen.newpv V2973) (let A (shen.newpv V2973) (do (shen.incinfs) (bind A (gensym shen.a) V2973 (freeze (bind B (set (shen.lazyderef A V2973) ()) V2973 (freeze (shen.findallhelp V2970 V2971 V2972 A V2973 V2974)))))))))

(defun shen.findallhelp (V2975 V2976 V2977 V2978 V2979 V2980) (let Case (do (shen.incinfs) (call V2976 V2979 (freeze (shen.remember V2978 V2975 V2979 (freeze (fwhen false V2979 V2980)))))) (if (= Case false) (do (shen.incinfs) (bind V2977 (value (shen.lazyderef V2978 V2979)) V2979 V2980)) Case)))

(defun shen.remember (V2981 V2982 V2983 V2984) (let B (shen.newpv V2983) (do (shen.incinfs) (bind B (set (shen.deref V2981 V2983) (cons (shen.deref V2982 V2983) (value (shen.deref V2981 V2983)))) V2983 V2984))))

(defun shen.t*-defcc (V2985 V2986 V2987 V2988 V2989) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2476 (shen.lazyderef V2985 V2988) (if (cons? V2476) (let V2477 (shen.lazyderef (hd V2476) V2988) (if (= defcc V2477) (let V2478 (shen.lazyderef (tl V2476) V2988) (if (cons? V2478) (let F (hd V2478) (let V2479 (shen.lazyderef (tl V2478) V2988) (if (cons? V2479) (let V2480 (shen.lazyderef (hd V2479) V2988) (if (= { V2480) (let V2481 (shen.lazyderef (tl V2479) V2988) (if (cons? V2481) (let V2482 (shen.lazyderef (hd V2481) V2988) (if (cons? V2482) (let V2483 (shen.lazyderef (hd V2482) V2988) (if (= list V2483) (let V2484 (shen.lazyderef (tl V2482) V2988) (if (cons? V2484) (let A (hd V2484) (let V2485 (shen.lazyderef (tl V2484) V2988) (if (= () V2485) (let V2486 (shen.lazyderef (tl V2481) V2988) (if (cons? V2486) (let V2487 (shen.lazyderef (hd V2486) V2988) (if (= ==> V2487) (let V2488 (shen.lazyderef (tl V2486) V2988) (if (cons? V2488) (let B (hd V2488) (let V2489 (shen.lazyderef (tl V2488) V2988) (if (cons? V2489) (let V2490 (shen.lazyderef (hd V2489) V2988) (if (= } V2490) (let Rest (tl V2489) (let Rest& (shen.newpv V2988) (let Rest&& (shen.newpv V2988) (let Rules (shen.newpv V2988) (let ListA&& (shen.newpv V2988) (let B&& (shen.newpv V2988) (let Sig (shen.newpv V2988) (let Declare (shen.newpv V2988) (do (shen.incinfs) (bind Sig (shen.ue (cons (cons list (cons (shen.lazyderef A V2988) ())) (cons ==> (cons (shen.lazyderef B V2988) ())))) V2988 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2988)) V2988 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2988)))) V2988 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2988)) V2988 (freeze (bind Rest&& (shen.ue (shen.lazyderef Rest& V2988)) V2988 (freeze (shen.get-rules Rules Rest&& V2988 (freeze (cut Throwcontrol V2988 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2987) 1 V2988 (freeze (unify V2986 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2988 (freeze (bind Declare (declare (shen.lazyderef F V2988) (cons (cons list (cons (shen.lazyderef A V2988) ())) (cons ==> (cons (shen.lazyderef B V2988) ())))) V2988 V2989)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2990) (cond ((cons? V2990) (map shen.plug-wildcards V2990)) ((= V2990 _) (gensym (intern "X"))) (true V2990)))

(defun shen.get-rules (V2991 V2992 V2993 V2994) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2469 (shen.lazyderef V2991 V2993) (if (= () V2469) (let V2470 (shen.lazyderef V2992 V2993) (if (= () V2470) (do (shen.incinfs) (cut Throwcontrol V2993 V2994)) false)) (if (shen.pvar? V2469) (do (shen.bindv V2469 () V2993) (let Result (let V2471 (shen.lazyderef V2992 V2993) (if (= () V2471) (do (shen.incinfs) (cut Throwcontrol V2993 V2994)) false)) (do (shen.unbindv V2469 V2993) Result))) false))) (if (= Case false) (let V2472 (shen.lazyderef V2991 V2993) (if (cons? V2472) (let Rule (hd V2472) (let Rules (tl V2472) (let Other (shen.newpv V2993) (do (shen.incinfs) (shen.first-rule V2992 Rule Other V2993 (freeze (cut Throwcontrol V2993 (freeze (shen.get-rules Rules Other V2993 V2994))))))))) (if (shen.pvar? V2472) (let Rule (shen.newpv V2993) (let Rules (shen.newpv V2993) (do (shen.bindv V2472 (cons Rule Rules) V2993) (let Result (let Other (shen.newpv V2993) (do (shen.incinfs) (shen.first-rule V2992 Rule Other V2993 (freeze (cut Throwcontrol V2993 (freeze (shen.get-rules Rules Other V2993 V2994))))))) (do (shen.unbindv V2472 V2993) Result))))) false))) Case)))))

(defun shen.first-rule (V2995 V2996 V2997 V2998 V2999) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2462 (shen.lazyderef V2995 V2998) (if (cons? V2462) (let V2463 (shen.lazyderef (hd V2462) V2998) (if (= ; V2463) (let Other2457 (tl V2462) (let V2464 (shen.lazyderef V2996 V2998) (if (= () V2464) (do (shen.incinfs) (unify! V2997 Other2457 V2998 (freeze (cut Throwcontrol V2998 V2999)))) (if (shen.pvar? V2464) (do (shen.bindv V2464 () V2998) (let Result (do (shen.incinfs) (unify! V2997 Other2457 V2998 (freeze (cut Throwcontrol V2998 V2999)))) (do (shen.unbindv V2464 V2998) Result))) false)))) false)) false)) (if (= Case false) (let V2465 (shen.lazyderef V2995 V2998) (if (cons? V2465) (let X2458 (hd V2465) (let Rest (tl V2465) (let V2466 (shen.lazyderef V2996 V2998) (if (cons? V2466) (let X (hd V2466) (let Rule (tl V2466) (do (shen.incinfs) (unify! X X2458 V2998 (freeze (shen.first-rule Rest Rule V2997 V2998 V2999)))))) (if (shen.pvar? V2466) (let X (shen.newpv V2998) (let Rule (shen.newpv V2998) (do (shen.bindv V2466 (cons X Rule) V2998) (let Result (do (shen.incinfs) (unify! X X2458 V2998 (freeze (shen.first-rule Rest Rule V2997 V2998 V2999)))) (do (shen.unbindv V2466 V2998) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V3000 V3001 V3002 V3003 V3004 V3005 V3006 V3007) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2451 (shen.lazyderef V3001 V3006) (if (= () V2451) (do (shen.incinfs) (thaw V3007)) false)) (if (= Case false) (let V2452 (shen.lazyderef V3001 V3006) (if (cons? V2452) (let Rule (hd V2452) (let Rules (tl V2452) (let V2453 (shen.lazyderef V3002 V3006) (if (cons? V2453) (let V2454 (shen.lazyderef (hd V2453) V3006) (if (= list V2454) (let V2455 (shen.lazyderef (tl V2453) V3006) (if (cons? V2455) (let A (hd V2455) (let V2456 (shen.lazyderef (tl V2455) V3006) (if (= () V2456) (let M (shen.newpv V3006) (do (shen.incinfs) (shen.tc-rule V3000 Rule A V3003 V3004 V3005 V3006 (freeze (bind M (+ (shen.deref V3005 V3006) 1) V3006 (freeze (cut Throwcontrol V3006 (freeze (shen.tc-rules V3000 Rules (cons list (cons A ())) V3003 V3004 M V3006 V3007))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V3008 V3009 V3010 V3011 V3012 V3013 V3014 V3015) (let Case (do (shen.incinfs) (shen.check-defcc-rule V3009 V3010 V3011 V3012 V3014 V3015)) (if (= Case false) (let Err (shen.newpv V3014) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3013 V3014) (cn " of " (shen.app (shen.lazyderef V3008 V3014) "" shen.a)) shen.a))) V3014 V3015))) Case)))

(defun shen.check-defcc-rule (V3016 V3017 V3018 V3019 V3020 V3021) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V3020) (let Semantics (shen.newpv V3020) (let SynHyps (shen.newpv V3020) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V3016 V3020 (freeze (cut Throwcontrol V3020 (freeze (shen.syntax-hyps Syntax V3019 SynHyps V3017 V3020 (freeze (cut Throwcontrol V3020 (freeze (shen.syntax-check Syntax V3017 SynHyps V3020 (freeze (cut Throwcontrol V3020 (freeze (shen.semantics-check Semantics V3018 SynHyps V3020 V3021))))))))))))))))))))

(defun shen.syntax-hyps (V3022 V3023 V3024 V3025 V3026 V3027) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2424 (shen.lazyderef V3022 V3026) (if (= () V2424) (do (shen.incinfs) (unify! V3024 V3023 V3026 V3027)) false)) (if (= Case false) (let Case (let V2425 (shen.lazyderef V3022 V3026) (if (cons? V2425) (let X2418 (hd V2425) (let Y (tl V2425) (let V2426 (shen.lazyderef V3024 V3026) (if (cons? V2426) (let V2427 (shen.lazyderef (hd V2426) V3026) (if (cons? V2427) (let X (hd V2427) (let V2428 (shen.lazyderef (tl V2427) V3026) (if (cons? V2428) (let V2429 (shen.lazyderef (hd V2428) V3026) (if (= : V2429) (let V2430 (shen.lazyderef (tl V2428) V3026) (if (cons? V2430) (let A2419 (hd V2430) (let V2431 (shen.lazyderef (tl V2430) V3026) (if (= () V2431) (let SynHyps (tl V2426) (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (if (shen.pvar? V2431) (do (shen.bindv V2431 () V3026) (let Result (let SynHyps (tl V2426) (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2431 V3026) Result))) false)))) (if (shen.pvar? V2430) (let A2419 (shen.newpv V3026) (do (shen.bindv V2430 (cons A2419 ()) V3026) (let Result (let SynHyps (tl V2426) (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2430 V3026) Result)))) false))) (if (shen.pvar? V2429) (do (shen.bindv V2429 : V3026) (let Result (let V2432 (shen.lazyderef (tl V2428) V3026) (if (cons? V2432) (let A2419 (hd V2432) (let V2433 (shen.lazyderef (tl V2432) V3026) (if (= () V2433) (let SynHyps (tl V2426) (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (if (shen.pvar? V2433) (do (shen.bindv V2433 () V3026) (let Result (let SynHyps (tl V2426) (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2433 V3026) Result))) false)))) (if (shen.pvar? V2432) (let A2419 (shen.newpv V3026) (do (shen.bindv V2432 (cons A2419 ()) V3026) (let Result (let SynHyps (tl V2426) (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2432 V3026) Result)))) false))) (do (shen.unbindv V2429 V3026) Result))) false))) (if (shen.pvar? V2428) (let A2419 (shen.newpv V3026) (do (shen.bindv V2428 (cons : (cons A2419 ())) V3026) (let Result (let SynHyps (tl V2426) (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2428 V3026) Result)))) false)))) (if (shen.pvar? V2427) (let X (shen.newpv V3026) (let A2419 (shen.newpv V3026) (do (shen.bindv V2427 (cons X (cons : (cons A2419 ()))) V3026) (let Result (let SynHyps (tl V2426) (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2427 V3026) Result))))) false))) (if (shen.pvar? V2426) (let X (shen.newpv V3026) (let A2419 (shen.newpv V3026) (let SynHyps (shen.newpv V3026) (do (shen.bindv V2426 (cons (cons X (cons : (cons A2419 ()))) SynHyps) V3026) (let Result (do (shen.incinfs) (unify! V3025 A2419 V3026 (freeze (unify! X X2418 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027)))))))))) (do (shen.unbindv V2426 V3026) Result)))))) false))))) false)) (if (= Case false) (let V2434 (shen.lazyderef V3022 V3026) (if (cons? V2434) (let Y (tl V2434) (do (shen.incinfs) (shen.syntax-hyps Y V3023 V3024 V3025 V3026 V3027))) false)) Case)) Case)))))

(defun shen.get-syntax+semantics (V3028 V3029 V3030 V3031 V3032) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2390 (shen.lazyderef V3028 V3031) (if (= () V2390) (let V2391 (shen.lazyderef V3030 V3031) (if (cons? V2391) (let V2392 (shen.lazyderef (hd V2391) V3031) (if (= := V2392) (let V2393 (shen.lazyderef (tl V2391) V3031) (if (cons? V2393) (let Semantics (hd V2393) (let V2394 (shen.lazyderef (tl V2393) V3031) (if (= () V2394) (do (shen.incinfs) (cut Throwcontrol V3031 (freeze (bind V3029 (shen.lazyderef Semantics V3031) V3031 V3032)))) false))) false)) false)) false)) (if (shen.pvar? V2390) (do (shen.bindv V2390 () V3031) (let Result (let V2395 (shen.lazyderef V3030 V3031) (if (cons? V2395) (let V2396 (shen.lazyderef (hd V2395) V3031) (if (= := V2396) (let V2397 (shen.lazyderef (tl V2395) V3031) (if (cons? V2397) (let Semantics (hd V2397) (let V2398 (shen.lazyderef (tl V2397) V3031) (if (= () V2398) (do (shen.incinfs) (cut Throwcontrol V3031 (freeze (bind V3029 (shen.lazyderef Semantics V3031) V3031 V3032)))) false))) false)) false)) false)) (do (shen.unbindv V2390 V3031) Result))) false))) (if (= Case false) (let Case (let V2399 (shen.lazyderef V3028 V3031) (if (= () V2399) (let V2400 (shen.lazyderef V3030 V3031) (if (cons? V2400) (let V2401 (shen.lazyderef (hd V2400) V3031) (if (= := V2401) (let V2402 (shen.lazyderef (tl V2400) V3031) (if (cons? V2402) (let Semantics (hd V2402) (let V2403 (shen.lazyderef (tl V2402) V3031) (if (cons? V2403) (let V2404 (shen.lazyderef (hd V2403) V3031) (if (= where V2404) (let V2405 (shen.lazyderef (tl V2403) V3031) (if (cons? V2405) (let G (hd V2405) (let V2406 (shen.lazyderef (tl V2405) V3031) (if (= () V2406) (do (shen.incinfs) (cut Throwcontrol V3031 (freeze (bind V3029 (cons where (cons (shen.lazyderef G V3031) (cons (shen.lazyderef Semantics V3031) ()))) V3031 V3032)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2399) (do (shen.bindv V2399 () V3031) (let Result (let V2407 (shen.lazyderef V3030 V3031) (if (cons? V2407) (let V2408 (shen.lazyderef (hd V2407) V3031) (if (= := V2408) (let V2409 (shen.lazyderef (tl V2407) V3031) (if (cons? V2409) (let Semantics (hd V2409) (let V2410 (shen.lazyderef (tl V2409) V3031) (if (cons? V2410) (let V2411 (shen.lazyderef (hd V2410) V3031) (if (= where V2411) (let V2412 (shen.lazyderef (tl V2410) V3031) (if (cons? V2412) (let G (hd V2412) (let V2413 (shen.lazyderef (tl V2412) V3031) (if (= () V2413) (do (shen.incinfs) (cut Throwcontrol V3031 (freeze (bind V3029 (cons where (cons (shen.lazyderef G V3031) (cons (shen.lazyderef Semantics V3031) ()))) V3031 V3032)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2399 V3031) Result))) false))) (if (= Case false) (let V2414 (shen.lazyderef V3028 V3031) (if (cons? V2414) (let X2386 (hd V2414) (let Syntax (tl V2414) (let V2415 (shen.lazyderef V3030 V3031) (if (cons? V2415) (let X (hd V2415) (let Rule (tl V2415) (do (shen.incinfs) (unify! X X2386 V3031 (freeze (shen.get-syntax+semantics Syntax V3029 Rule V3031 V3032)))))) false)))) (if (shen.pvar? V2414) (let X2386 (shen.newpv V3031) (let Syntax (shen.newpv V3031) (do (shen.bindv V2414 (cons X2386 Syntax) V3031) (let Result (let V2416 (shen.lazyderef V3030 V3031) (if (cons? V2416) (let X (hd V2416) (let Rule (tl V2416) (do (shen.incinfs) (unify! X X2386 V3031 (freeze (shen.get-syntax+semantics Syntax V3029 Rule V3031 V3032)))))) false)) (do (shen.unbindv V2414 V3031) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V3033 V3034 V3035 V3036 V3037) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2383 (shen.lazyderef V3033 V3036) (if (= () V2383) (do (shen.incinfs) (thaw V3037)) false)) (if (= Case false) (let Case (let V2384 (shen.lazyderef V3033 V3036) (if (cons? V2384) (let X (hd V2384) (let Syntax (tl V2384) (let C (shen.newpv V3036) (let X&& (shen.newpv V3036) (let B (shen.newpv V3036) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V3036)) V3036 (freeze (cut Throwcontrol V3036 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V3035 V3036 (freeze (cut Throwcontrol V3036 (freeze (bind X&& (concat && (shen.lazyderef X V3036)) V3036 (freeze (cut Throwcontrol V3036 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V3034 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V3035) V3036 (freeze (cut Throwcontrol V3036 (freeze (shen.syntax-check Syntax V3034 V3035 V3036 V3037))))))))))))))))))))))) false)) (if (= Case false) (let V2385 (shen.lazyderef V3033 V3036) (if (cons? V2385) (let X (hd V2385) (let Syntax (tl V2385) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V3034 ()))) V3035 V3036 (freeze (cut Throwcontrol V3036 (freeze (shen.syntax-check Syntax V3034 V3035 V3036 V3037)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3038 V3039 V3040 V3041 V3042) (let Semantics* (shen.newpv V3041) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3038 V3041))) V3041 (freeze (shen.t* (cons Semantics* (cons : (cons V3039 ()))) V3040 V3041 V3042))))))

(defun shen.rename-semantics (V3043) (cond ((cons? V3043) (cons (shen.rename-semantics (hd V3043)) (shen.rename-semantics (tl V3043)))) ((shen.grammar_symbol? V3043) (cons shen.<-sem (cons V3043 ()))) (true V3043)))



